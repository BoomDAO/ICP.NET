<?xml version="1.0"?>
<doc>
    <assembly>
        <name>EdjCase.ICP.Candid</name>
    </assembly>
    <members>
        <member name="M:EdjCase.ICP.Candid.BinarySequence.#ctor(System.Boolean[])">
            <param name="bits">Least signifcant to most ordered bits</param>
        </member>
        <member name="F:EdjCase.ICP.Candid.CandidArgBuilder.compoundTypeTable">
            <summary>
            Helper to capture compound types
            </summary>
        </member>
        <member name="F:EdjCase.ICP.Candid.CandidArgBuilder.EncodedTypes">
            <summary>
            Ordered list of encoded types (encoded with SLEB128).
            If SLEB value is positive, it is an index for `EncodedCompoundTypes` for a compound type
            If SLEB value is negative, it is type code for a primitive value
            </summary>
        </member>
        <member name="F:EdjCase.ICP.Candid.CandidArgBuilder.EncodedValues">
            <summary>
            Ordered list of encoded values
            </summary>
        </member>
        <member name="T:EdjCase.ICP.Candid.Crypto.CRC32">
            <summary>
            Helper class for computing CRC32 hashes/checksums on byte data
            Useful for calculating checksums on data
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Candid.Crypto.CRC32.ComputeHash(System.IO.Stream)">
            <summary>
            Computes the 32-bit hash on the stream of data provided
            </summary>
            <param name="stream">Byte data. Will use the whole stream</param>
            <returns>Hash of the byte data as a byte array of length of 4</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Crypto.CRC32.ComputeHash(System.Byte[])">
            <summary>
            Computes the 32-bit hash on the data bytes provided
            </summary>
            <param name="data">Byte data</param>
            <returns>Hash of the byte data as a byte array of length of 4</returns>
        </member>
        <member name="T:EdjCase.ICP.Candid.Crypto.IHashFunction">
            <summary>
            Interface to implement different hash function algorithms against
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Candid.Crypto.IHashFunction.ComputeHash(System.Byte[])">
            <summary>
            Computes the hash of the byte array based on the algorithm implemented
            </summary>
            <param name="value">Byte array to get the hash of</param>
            <returns>Hash in the form of a byte array</returns>
        </member>
        <member name="T:EdjCase.ICP.Candid.Crypto.SHA256HashFunction">
            <summary>
            A SHA256 implementation of the `IHashFunction`
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Candid.Crypto.SHA256HashFunction.ComputeHash(System.Byte[])">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Crypto.SHA256HashFunction.Create">
            <summary>
            Helper method to create the hash function object
            </summary>
            <returns>Hash function object</returns>
        </member>
        <member name="T:EdjCase.ICP.Candid.Encodings.LEB128">
            <summary>
            Utility class to provide methods for LEB128 encoding (https://en.wikipedia.org/wiki/LEB128)
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Candid.Encodings.LEB128.DecodeUnsigned(System.Byte[])">
            <summary>
            Takes a byte encoded unsigned LEB128 and converts it to an `UnboundedUInt`
            </summary>
            <param name="encodedValue">Byte value of an unsigned LEB128</param>
            <returns>`UnboundedUInt` of LEB128 value</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Encodings.LEB128.DecodeUnsigned(System.IO.Stream)">
            <summary>
            Takes a encoded unsigned LEB128 byte stream and converts it to an `UnboundedUInt`
            </summary>
            <param name="stream">Byte stream of an unsigned LEB128</param>
            <returns>`UnboundedUInt` of LEB128 value</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Encodings.LEB128.DecodeSigned(System.IO.Stream)">
            <summary>
            Takes a encoded signed LEB128 byte stream and converts it to an `UnboundedInt`
            </summary>
            <param name="stream">Byte stream of a signed LEB128</param>
            <returns>`UnboundedInt` of LEB128 value</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Encodings.LEB128.EncodeUnsigned(EdjCase.ICP.Candid.Models.UnboundedUInt)">
            <summary>
            Takes an `UnboundedUInt` and converts it into an encoded unsigned LEB128 byte array
            </summary>
            <param name="value">Value to convert to LEB128 bytes</param>
            <returns>LEB128 bytes of value</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Encodings.LEB128.EncodeSigned(EdjCase.ICP.Candid.Models.UnboundedInt)">
            <summary>
            Takes an `UnboundedInt` and converts it into an encoded signed LEB128 byte array
            </summary>
            <param name="value">Value to convert to LEB128 bytes</param>
            <returns>LEB128 bytes of value</returns>
        </member>
        <member name="T:EdjCase.ICP.Candid.Exceptions.CandidDecodingException">
            <summary>
            An error that occurs during the decoding of bytes to a candid structure
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Candid.Exceptions.CandidDecodingException.ByteEndIndex">
            <summary>
            The index where the byte reader last read. Helps identitfy the source of the 
            decoding issue
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Candid.Exceptions.CandidDecodingException.ErrorMessage">
            <summary>
            Message about the error that occurred
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Candid.Exceptions.CandidDecodingException.#ctor(System.Int32,System.String)">
            <param name="byteEndIndex">The index where the byte reader last read</param>
            <param name="message">Message about the error that occurred</param>
        </member>
        <member name="P:EdjCase.ICP.Candid.Exceptions.CandidDecodingException.Message">
            <inheritdoc/>
        </member>
        <member name="T:EdjCase.ICP.Candid.Exceptions.CandidTextParseException">
            <summary>
            An error that occurs when the conversion of text to a candid model fails
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Candid.Exceptions.CandidTextParseException.Message">
            <inheritdoc/>
        </member>
        <member name="T:EdjCase.ICP.Candid.Exceptions.InvalidCandidException">
            <summary>
            An error that occurs if the candid models do not follow the 
            specification
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Candid.Exceptions.InvalidCandidException.Message">
            <inheritdoc/>
        </member>
        <member name="T:EdjCase.ICP.Candid.Mapping.IObjectMapper">
            <summary>
            A custom mapper interface to map a C# type to and from a candid type
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Candid.Mapping.IObjectMapper.CandidType">
            <summary>
            Candid type to convert to/from
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Candid.Mapping.IObjectMapper.Type">
            <summary>
            C# type to convert to/from
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Candid.Mapping.IObjectMapper.Map(EdjCase.ICP.Candid.Models.Values.CandidValue,EdjCase.ICP.Candid.CandidConverterOptions)">
            <summary>
            Maps a candid value to a C# value.
            Input value will match the `CandidType` type property.
            Returned value should match the `Type` type property.
            </summary>
            <param name="value">Candid value to map to a C# value</param>
            <param name="options">Options that are being used for the mappings</param>
            <returns>C# value converted from the candid value</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Mapping.IObjectMapper.Map(System.Object,EdjCase.ICP.Candid.CandidConverterOptions)">
            <summary>
            Maps a C# value to a candid value and type.
            Input value will match the `Type` type property.
            Returned value should match the `CandidType` type property.
            </summary>
            <param name="value">C# value to map to a candid value</param>
            <param name="options">Options that are being used for the mappings</param>
            <returns>Candid value and type converted from the C# value</returns>
        </member>
        <member name="T:EdjCase.ICP.Candid.Mapping.CandidNameAttribute">
            <summary>
            An attribute to specify a candid name to use for serialization. If unspecified 
            the serializers will use the property names
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Candid.Mapping.CandidNameAttribute.Name">
            <summary>
            The name to use for serialization of candid values
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Candid.Mapping.CandidNameAttribute.#ctor(System.String)">
            <param name="name">The name to use for serialization of candid values</param>
        </member>
        <member name="T:EdjCase.ICP.Candid.Mapping.CustomMapperAttribute">
            <summary>
            An attribute that specifies a custom mapper for the class, struct, property or field
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Candid.Mapping.CustomMapperAttribute.Mapper">
            <summary>
            The object mapper to use for the decorated item
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Candid.Mapping.CustomMapperAttribute.#ctor(EdjCase.ICP.Candid.Mapping.IObjectMapper)">
            <param name="mapper">The object mapper to use for the decorated item</param>
        </member>
        <member name="T:EdjCase.ICP.Candid.Mapping.CandidIgnoreAttribute">
            <summary>
            An attribute to ignore a property/field of a class during serialization
            </summary>
        </member>
        <member name="T:EdjCase.ICP.Candid.Mapping.VariantAttribute">
            <summary>
            An attribute to put on a class to identify it as a variant type for serialization.
            Requires the use of `VariantTagPropertyAttribute`, `VariantOptionTypeAttribute` and
            `VariantValuePropertyAttribute` attributes if used
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Candid.Mapping.VariantAttribute.TagType">
            <summary>
            The enum type to use for specifying the tags of the variant
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Candid.Mapping.VariantAttribute.#ctor(System.Type)">
            <param name="enumType">The enum type to use for specifying the tags of the variant</param>
            <exception cref="T:System.ArgumentException">Throws if the type is not an enum</exception>
        </member>
        <member name="T:EdjCase.ICP.Candid.Mapping.VariantTagPropertyAttribute">
            <summary>
            An attribute to put on a property/field that indicates where to hold the 
            tag enum value. Must match the type passed to the `VariantAttribute`
            </summary>
        </member>
        <member name="T:EdjCase.ICP.Candid.Mapping.VariantValuePropertyAttribute">
            <summary>
            An attribute to put on a property/field that indicates where to hold the
            tag value object. The type must be compatible with all value types, recommend using `object?`
            </summary>
        </member>
        <member name="T:EdjCase.ICP.Candid.Mapping.VariantOptionTypeAttribute">
            <summary>
            An attribute to put on an enum option to specify if the tag has an attached
            value in the variant, otherwise the attached type will be null
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Candid.Mapping.VariantOptionTypeAttribute.OptionType">
            <summary>
            The type of the variant option value to use
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Candid.Mapping.VariantOptionTypeAttribute.#ctor(System.Type)">
            <param name="optionType">The type of the variant option value to use</param>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.CandidArg.ComputeHash(EdjCase.ICP.Candid.Crypto.IHashFunction)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.CandidArg.ToString">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.CandidArg.Equals(EdjCase.ICP.Candid.Models.CandidArg)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.CandidArg.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.CandidArg.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.CandidArg.op_Equality(EdjCase.ICP.Candid.Models.CandidArg,EdjCase.ICP.Candid.Models.CandidArg)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.CandidArg.op_Inequality(EdjCase.ICP.Candid.Models.CandidArg,EdjCase.ICP.Candid.Models.CandidArg)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.CandidId.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.CandidId.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.CandidId.Equals(EdjCase.ICP.Candid.Models.CandidId)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.CandidId.Equals(System.String)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.CandidId.op_Equality(EdjCase.ICP.Candid.Models.CandidId,EdjCase.ICP.Candid.Models.CandidId)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.CandidId.op_Inequality(EdjCase.ICP.Candid.Models.CandidId,EdjCase.ICP.Candid.Models.CandidId)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.CandidId.ToString">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.CandidId.CompareTo(EdjCase.ICP.Candid.Models.CandidId)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.CandidTag.HashName(System.String)">
            <summary>
            Hashes the name to get the proper id 
            hash(name) = ( Sum_(i=0..k) utf8(name)[i] * 223^(k-i) ) mod 2^32 where k = |utf8(name)|-1
            </summary>
            <param name="name">Name to hash</param>
            <returns>Unsigned 32 byte integer hash</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.CandidTypedValue.AsPrincipal">
            <summary>
            If opaque, returns null, otherwise the principalid
            </summary>
            <returns></returns>
        </member>
        <member name="F:EdjCase.ICP.Candid.Models.CompoundTypeTable.CompoundTypeIndexMap">
            <summary>
            A mapping of compound type definition to `EncodedCompoundTypes` index to be used as reference
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.HashTree.BuildRootHash">
            <summary>
            Computes the root SHA256 hash of the tree based on the IC certificate spec
            </summary>
            <returns>A blob of the hash digest</returns>
        </member>
        <member name="T:EdjCase.ICP.Candid.Models.Types.CandidKnownType">
            <summary>
            A candid type that is NOT a reference type. This type is known before any resolution
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Types.CandidKnownType.Type">
            <summary>
            The candid type that this model represents
            </summary>
        </member>
        <member name="T:EdjCase.ICP.Candid.Models.Types.CandidType">
            <summary>
            The base candid type model that all candid types inherit
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidType.Encode(EdjCase.ICP.Candid.Models.CompoundTypeTable)">
            <summary>
            Encodes this type into a byte array. If its a primitive type the value will
            be an encoded negative number, if its a compound type it will be added to the 
            type table and be a positive number of the table index where its info is stored
            </summary>
            <param name="compoundTypeTable">The collection of compound types for a candid arg</param>
            <returns>Byte array of the type number</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidType.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidType.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidType.ToString">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidType.Equals(EdjCase.ICP.Candid.Models.Types.CandidType)">
            <summary>
            Checks for equality of this type against the specified type
            </summary>
            <param name="other">Another type to compare against</param>
            <returns>True if they are structurally the same, otherwise false</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidType.op_Equality(EdjCase.ICP.Candid.Models.Types.CandidType,EdjCase.ICP.Candid.Models.Types.CandidType)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidType.op_Inequality(EdjCase.ICP.Candid.Models.Types.CandidType,EdjCase.ICP.Candid.Models.Types.CandidType)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidType.Text">
            <summary>
            Helper method to create a Text candid type
            </summary>
            <returns>Text candid type</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidType.Nat">
            <summary>
            Helper method to create a Nat candid type
            </summary>
            <returns>Nat candid type</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidType.Nat8">
            <summary>
            Helper method to create a Nat8 candid type
            </summary>
            <returns>Nat8 candid type</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidType.Nat16">
            <summary>
            Helper method to create a Nat16 candid type
            </summary>
            <returns>Nat16 candid type</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidType.Nat32">
            <summary>
            Helper method to create a Nat32 candid type
            </summary>
            <returns>Nat32 candid type</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidType.Nat64">
            <summary>
            Helper method to create a Nat64 candid type
            </summary>
            <returns>Nat64 candid type</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidType.Int">
            <summary>
            Helper method to create a Int candid type
            </summary>
            <returns>Int candid type</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidType.Int8">
            <summary>
            Helper method to create a Int8 candid type
            </summary>
            <returns>Int8 candid type</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidType.Int16">
            <summary>
            Helper method to create a Int16 candid type
            </summary>
            <returns>Int16 candid type</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidType.Int32">
            <summary>
            Helper method to create a Int32 candid type
            </summary>
            <returns>Int32 candid type</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidType.Int64">
            <summary>
            Helper method to create a Int64 candid type
            </summary>
            <returns>Int64 candid type</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidType.Float32">
            <summary>
            Helper method to create a Float32 candid type
            </summary>
            <returns>Float32 candid type</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidType.Float64">
            <summary>
            Helper method to create a Float64 candid type
            </summary>
            <returns>Float64 candid type</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidType.Bool">
            <summary>
            Helper method to create a Bool candid type
            </summary>
            <returns>Bool candid type</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidType.Principal">
            <summary>
            Helper method to create a Principal candid type
            </summary>
            <returns>Principal candid type</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidType.Null">
            <summary>
            Helper method to create a Null candid type
            </summary>
            <returns>Null candid type</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidType.Reserved">
            <summary>
            Helper method to create a Reserved candid type
            </summary>
            <returns>Reserved candid type</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidType.Empty">
            <summary>
            Helper method to create a Empty candid type
            </summary>
            <returns>Empty candid type</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidType.Opt(EdjCase.ICP.Candid.Models.Types.CandidType)">
            <summary>
            Helper method to create a Opt candid type
            </summary>
            <returns>Opt candid type</returns>
        </member>
        <member name="T:EdjCase.ICP.Candid.Models.Types.CandidCompoundType">
            <summary>
            A candid type that is not primitive or a reference. These types are considered
            more complex and have multiple data structures within them
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Types.CandidCompoundType.RecursiveId">
            <summary>
            Optional. Used if this type can be referenced by an inner type recursively.
            The inner type will use `CandidReferenceType` with this id
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidCompoundType.#ctor(EdjCase.ICP.Candid.Models.CandidId)">
            <param name="recursiveId">Optional. Used if this type can be referenced by an inner type recursively.
            The inner type will use `CandidReferenceType` with this id</param>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidCompoundType.EncodeInnerTypes(EdjCase.ICP.Candid.Models.CompoundTypeTable)">
            <summary>
            Adds all inner types to the compound table if applicable and returns its encoded type value
            </summary>
            <param name="compoundTypeTable">The collection of compound types for a candid arg</param>
            <returns>Byte array of encoded type</returns>
        </member>
        <member name="T:EdjCase.ICP.Candid.Models.Types.CandidRecordOrVariantType">
            <summary>
            A shared class for candid records and variants. Both have a mapping of 
            keys with associated types
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Types.CandidRecordOrVariantType.Type">
            <inheritdoc />
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Types.CandidRecordOrVariantType.TypeString">
            <summary>
            The string name of the parent type (record or variant)
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidRecordOrVariantType.GetFieldsOrOptions">
            <summary>
            Gets the record fields or variant options to be used for encoding
            </summary>
            <returns></returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidRecordOrVariantType.#ctor(EdjCase.ICP.Candid.Models.CandidId)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidRecordOrVariantType.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidRecordOrVariantType.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:EdjCase.ICP.Candid.Models.Types.FuncMode">
            <summary>
            All the possible options for function modes which
            define special attributes of the function
            </summary>
        </member>
        <member name="F:EdjCase.ICP.Candid.Models.Types.FuncMode.Oneway">
            <summary>
            Mode where the function does not generate a response to a request
            </summary>
        </member>
        <member name="F:EdjCase.ICP.Candid.Models.Types.FuncMode.Query">
            <summary>
            Mode where the function does not update any state and returns immediately.
            Is useful for faster data retrieval
            </summary>
        </member>
        <member name="T:EdjCase.ICP.Candid.Models.Types.CandidFuncType">
            <summary>
            A candid type model that defines a func
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Types.CandidFuncType.Type">
            <inheritdoc />
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Types.CandidFuncType.Modes">
            <summary>
            A set of different modes the function supports
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Types.CandidFuncType.ArgTypes">
            <summary>
            A list of all the argument types the function will need in a request.
            The name is optional and is only used for ease of use, the index/position
            of the argument is all that really matters
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Types.CandidFuncType.ReturnTypes">
            <summary>
            A list of all the return types the function will supply in respose to a request.
            The name is optional and is only used for ease of use, the index/position
            of the argument is all that really matters
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidFuncType.#ctor(System.Collections.Generic.List{EdjCase.ICP.Candid.Models.Types.FuncMode},System.Collections.Generic.List{EdjCase.ICP.Candid.Models.Types.CandidType},System.Collections.Generic.List{EdjCase.ICP.Candid.Models.Types.CandidType},EdjCase.ICP.Candid.Models.CandidId)">
            <param name="modes">A set of different modes the function supports</param>
            <param name="argTypes">A list of all the argument types the function will need in a request.
            The name is optional and is only used for ease of use, the index/position
            of the argument is all that really matters</param>
            <param name="returnTypes">A list of all the return types the function will supply in respose to a request.
            The name is optional and is only used for ease of use, the index/position
            of the argument is all that really matters</param>
            <param name="recursiveId">Optional. Used if this type can be referenced by an inner type recursively.
            The inner type will use `CandidReferenceType` with this id</param>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidFuncType.#ctor(System.Collections.Generic.List{EdjCase.ICP.Candid.Models.Types.FuncMode},System.Collections.Generic.List{System.ValueTuple{EdjCase.ICP.Candid.Models.CandidId,EdjCase.ICP.Candid.Models.Types.CandidType}},System.Collections.Generic.List{System.ValueTuple{EdjCase.ICP.Candid.Models.CandidId,EdjCase.ICP.Candid.Models.Types.CandidType}},EdjCase.ICP.Candid.Models.CandidId)">
            <param name="modes">A set of different modes the function supports</param>
            <param name="argTypes">A list of all the argument types the function will need in a request.
            The name is optional and is only used for ease of use, the index/position
            of the argument is all that really matters</param>
            <param name="returnTypes">A list of all the return types the function will supply in respose to a request.
            The name is optional and is only used for ease of use, the index/position
            of the argument is all that really matters</param>
            <param name="recursiveId">Optional. Used if this type can be referenced by an inner type recursively.
            The inner type will use `CandidReferenceType` with this id</param>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidFuncType.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidFuncType.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:EdjCase.ICP.Candid.Models.Types.CandidOptionalType">
            <summary>
            A model for candid optional types
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Types.CandidOptionalType.Type">
            <inheritdoc />
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Types.CandidOptionalType.Value">
            <summary>
            The inner value type of the optional value, if the value is not null
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidOptionalType.#ctor(EdjCase.ICP.Candid.Models.Types.CandidType,EdjCase.ICP.Candid.Models.CandidId)">
            <param name="value">The inner value type of the optional value, if the value is not null</param>
            <param name="recursiveId">Optional. Used if this type can be referenced by an inner type recursively.
            The inner type will use `CandidReferenceType` with this id</param>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidOptionalType.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidOptionalType.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidPrimitiveType.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidPrimitiveType.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:EdjCase.ICP.Candid.Models.Types.CandidRecordType">
            <summary>
            A model for candid record types
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Types.CandidRecordType.Type">
            <inheritdoc />
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Types.CandidRecordType.TypeString">
            <inheritdoc />
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Types.CandidRecordType.Fields">
            <summary>
            The collection of field names with the associate type for that field
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidRecordType.#ctor(System.Collections.Generic.Dictionary{EdjCase.ICP.Candid.Models.CandidTag,EdjCase.ICP.Candid.Models.Types.CandidType},EdjCase.ICP.Candid.Models.CandidId)">
            <param name="fields">The collection of field names with the associate type for that field</param>
            <param name="recursiveId">Optional. Used if this type can be referenced by an inner type recursively.
            The inner type will use `CandidReferenceType` with this id</param>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidRecordType.GetFieldsOrOptions">
            <inheritdoc />
        </member>
        <member name="T:EdjCase.ICP.Candid.Models.Types.CandidReferenceType">
            <summary>
            A special candid type model that is a pointer to a different type.
            Usually due to recursive types where a parent type has an inner type
            that references that same parent type. The parent type must have a `RecursiveId`
            specified and the `Id` of the reference type must match that
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Types.CandidReferenceType.Id">
            <summary>
            The id to reference in a parent type. The parent type must have the `RecursiveId` specified
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidReferenceType.#ctor(EdjCase.ICP.Candid.Models.CandidId)">
            <param name="id">The id to reference in a parent type. The parent type must have the `RecursiveId` specified</param>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidReferenceType.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidReferenceType.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:EdjCase.ICP.Candid.Models.Types.CandidServiceType">
            <summary>
            A model for a candid service type
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Types.CandidServiceType.Type">
            <inheritdoc />
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Types.CandidServiceType.Methods">
            <summary>
            A mapping of ids to function types that the service contains
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidServiceType.#ctor(System.Collections.Generic.Dictionary{EdjCase.ICP.Candid.Models.CandidId,EdjCase.ICP.Candid.Models.Types.CandidFuncType},EdjCase.ICP.Candid.Models.CandidId)">
            <param name="methods">A mapping of ids to function types that the service contains</param>
            <param name="recursiveId">Optional. Used if this type can be referenced by an inner type recursively.
            The inner type will use `CandidReferenceType` with this id</param>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidServiceType.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidServiceType.GetHashCode">
            <inheritdoc />
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Types.CandidVariantType.Type">
            <inheritdoc />
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Types.CandidVectorType.Type">
            <inheritdoc />
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Types.CandidVectorType.InnerType">
            <summary>
            The type of the vectors inner values
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidVectorType.#ctor(EdjCase.ICP.Candid.Models.Types.CandidType,EdjCase.ICP.Candid.Models.CandidId)">
            <param name="innerType">The type of the vectors inner values</param>
            <param name="recursiveId">Optional. Used if this type can be referenced by an inner type recursively.
            The inner type will use `CandidReferenceType` with this id</param>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidVectorType.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidVectorType.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:EdjCase.ICP.Candid.Models.Values.CandidFunc">
            <summary>
            A model to represent the value of a candid func
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Values.CandidFunc.Type">
            <inheritdoc />
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Values.CandidFunc.IsOpaqueReference">
            <summary>
            True if the candid func definition is an opaque (non standard/system specific definition),
            otherwise false
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidFunc.#ctor(EdjCase.ICP.Candid.Models.Values.CandidService,System.String)">
            <param name="service">The candid service definition the function lives in</param>
            <param name="name">The name of the function</param>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidFunc.EncodeValue(EdjCase.ICP.Candid.Models.Types.CandidType,System.Func{EdjCase.ICP.Candid.Models.CandidId,EdjCase.ICP.Candid.Models.Types.CandidCompoundType})">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidFunc.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidFunc.Equals(EdjCase.ICP.Candid.Models.Values.CandidValue)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidFunc.ToString">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidFunc.OpaqueReference">
            <summary>
            Creates an opaque reference to a function that is defined by the system
            vs being defined in candid
            </summary>
            <returns>A opaque candid func</returns>
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Values.CandidOptional.Type">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidOptional.EncodeValue(EdjCase.ICP.Candid.Models.Types.CandidType,System.Func{EdjCase.ICP.Candid.Models.CandidId,EdjCase.ICP.Candid.Models.Types.CandidCompoundType})">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidOptional.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidOptional.Equals(EdjCase.ICP.Candid.Models.Values.CandidValue)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidOptional.ToString">
            <inheritdoc />
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Values.CandidPrimitive.Type">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidPrimitive.AsPrincipal">
            <summary>
            If opaque, returns null, otherwise the principalid
            </summary>
            <returns></returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidPrimitive.EncodeValue(EdjCase.ICP.Candid.Models.Types.CandidType,System.Func{EdjCase.ICP.Candid.Models.CandidId,EdjCase.ICP.Candid.Models.Types.CandidCompoundType})">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidPrimitive.ToString">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidPrimitive.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidPrimitive.Equals(EdjCase.ICP.Candid.Models.Values.CandidValue)">
            <inheritdoc />
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Values.CandidRecord.Type">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidRecord.EncodeValue(EdjCase.ICP.Candid.Models.Types.CandidType,System.Func{EdjCase.ICP.Candid.Models.CandidId,EdjCase.ICP.Candid.Models.Types.CandidCompoundType})">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidRecord.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidRecord.Equals(EdjCase.ICP.Candid.Models.Values.CandidValue)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidRecord.ToString">
            <inheritdoc />
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Values.CandidService.Type">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidService.EncodeValue(EdjCase.ICP.Candid.Models.Types.CandidType,System.Func{EdjCase.ICP.Candid.Models.CandidId,EdjCase.ICP.Candid.Models.Types.CandidCompoundType})">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidService.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidService.Equals(EdjCase.ICP.Candid.Models.Values.CandidValue)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidService.ToString">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidValue.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidValue.Equals(EdjCase.ICP.Candid.Models.Values.CandidValue)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidValue.ToString">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidValue.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidValue.op_Equality(EdjCase.ICP.Candid.Models.Values.CandidValue,EdjCase.ICP.Candid.Models.Values.CandidValue)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidValue.op_Inequality(EdjCase.ICP.Candid.Models.Values.CandidValue,EdjCase.ICP.Candid.Models.Values.CandidValue)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidValue.AsPrincipal">
            <summary>
            If opaque, returns null, otherwise the principalid
            </summary>
            <returns></returns>
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Values.CandidVariant.Type">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidVariant.EncodeValue(EdjCase.ICP.Candid.Models.Types.CandidType,System.Func{EdjCase.ICP.Candid.Models.CandidId,EdjCase.ICP.Candid.Models.Types.CandidCompoundType})">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidVariant.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidVariant.Equals(EdjCase.ICP.Candid.Models.Values.CandidValue)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidVariant.ToString">
            <inheritdoc />
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Values.CandidVector.Type">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidVector.EncodeValue(EdjCase.ICP.Candid.Models.Types.CandidType,System.Func{EdjCase.ICP.Candid.Models.CandidId,EdjCase.ICP.Candid.Models.Types.CandidCompoundType})">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidVector.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidVector.Equals(EdjCase.ICP.Candid.Models.Values.CandidValue)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidVector.ToString">
            <inheritdoc />
        </member>
        <member name="T:EdjCase.ICP.Candid.Parsers.CandidByteParser">
            <summary>
            Functions to help parse candid arguments from the raw bytes
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Candid.Parsers.CandidByteParser.Parse(System.Byte[])">
            <summary>
            Converts a byte representation of candid arguments to a usable model
            </summary>
            <param name="value">The byte representation of Candid arguments</param>
            <returns>Candid arg value from the specified bytes</returns>
            <exception cref="T:EdjCase.ICP.Candid.Exceptions.CandidDecodingException">Throws if the bytes are not valid Candid</exception>
            <exception cref="T:EdjCase.ICP.Candid.Exceptions.InvalidCandidException">Throws if the the candid does not follow the specification</exception>
            $"Candid failed with while resolving a type reference
        </member>
        <member name="T:System.Runtime.CompilerServices.IsExternalInit">
            <summary>
            Reserved to be used by the compiler for tracking metadata.
            This class should not be used by developers in source code.
            </summary>
        </member>
    </members>
</doc>
