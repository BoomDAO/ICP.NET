<?xml version="1.0"?>
<doc>
    <assembly>
        <name>EdjCase.ICP.Candid</name>
    </assembly>
    <members>
        <member name="M:EdjCase.ICP.Candid.BinarySequence.#ctor(System.Boolean[])">
            <param name="bits">Least signifcant to most ordered bits</param>
        </member>
        <member name="F:EdjCase.ICP.Candid.CandidArgBuilder.compoundTypeTable">
            <summary>
            Helper to capture compound types
            </summary>
        </member>
        <member name="F:EdjCase.ICP.Candid.CandidArgBuilder.EncodedTypes">
            <summary>
            Ordered list of encoded types (encoded with SLEB128).
            If SLEB value is positive, it is an index for `EncodedCompoundTypes` for a compound type
            If SLEB value is negative, it is type code for a primitive value
            </summary>
        </member>
        <member name="F:EdjCase.ICP.Candid.CandidArgBuilder.EncodedValues">
            <summary>
            Ordered list of encoded values
            </summary>
        </member>
        <member name="T:EdjCase.ICP.Candid.Crypto.CRC32">
            <summary>
            Helper class for computing CRC32 hashes/checksums on byte data
            Useful for calculating checksums on data
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Candid.Crypto.CRC32.ComputeHash(System.IO.Stream)">
            <summary>
            Computes the 32-bit hash on the stream of data provided
            </summary>
            <param name="stream">Byte data. Will use the whole stream</param>
            <returns>Hash of the byte data as a byte array of length of 4</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Crypto.CRC32.ComputeHash(System.Byte[])">
            <summary>
            Computes the 32-bit hash on the data bytes provided
            </summary>
            <param name="data">Byte data</param>
            <returns>Hash of the byte data as a byte array of length of 4</returns>
        </member>
        <member name="T:EdjCase.ICP.Candid.Crypto.IHashFunction">
            <summary>
            Interface to implement different hash function algorithms against
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Candid.Crypto.IHashFunction.ComputeHash(System.Byte[])">
            <summary>
            Computes the hash of the byte array based on the algorithm implemented
            </summary>
            <param name="value">Byte array to get the hash of</param>
            <returns>Hash in the form of a byte array</returns>
        </member>
        <member name="T:EdjCase.ICP.Candid.Crypto.SHA256HashFunction">
            <summary>
            A SHA256 implementation of the `IHashFunction`
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Candid.Crypto.SHA256HashFunction.ComputeHash(System.Byte[])">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Crypto.SHA256HashFunction.Create">
            <summary>
            Helper method to create the hash function object
            </summary>
            <returns>Hash function object</returns>
        </member>
        <member name="T:EdjCase.ICP.Candid.Encodings.LEB128">
            <summary>
            Utility class to provide methods for LEB128 encoding (https://en.wikipedia.org/wiki/LEB128)
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Candid.Encodings.LEB128.DecodeUnsigned(System.Byte[])">
            <summary>
            Takes a byte encoded unsigned LEB128 and converts it to an `UnboundedUInt`
            </summary>
            <param name="encodedValue">Byte value of an unsigned LEB128</param>
            <returns>`UnboundedUInt` of LEB128 value</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Encodings.LEB128.DecodeUnsigned(System.IO.Stream)">
            <summary>
            Takes a encoded unsigned LEB128 byte stream and converts it to an `UnboundedUInt`
            </summary>
            <param name="stream">Byte stream of an unsigned LEB128</param>
            <returns>`UnboundedUInt` of LEB128 value</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Encodings.LEB128.DecodeSigned(System.IO.Stream)">
            <summary>
            Takes a encoded signed LEB128 byte stream and converts it to an `UnboundedInt`
            </summary>
            <param name="stream">Byte stream of a signed LEB128</param>
            <returns>`UnboundedInt` of LEB128 value</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Encodings.LEB128.EncodeUnsigned(EdjCase.ICP.Candid.Models.UnboundedUInt)">
            <summary>
            Takes an `UnboundedUInt` and converts it into an encoded unsigned LEB128 byte array
            </summary>
            <param name="value">Value to convert to LEB128 bytes</param>
            <returns>LEB128 bytes of value</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Encodings.LEB128.EncodeSigned(EdjCase.ICP.Candid.Models.UnboundedInt)">
            <summary>
            Takes an `UnboundedInt` and converts it into an encoded signed LEB128 byte array
            </summary>
            <param name="value">Value to convert to LEB128 bytes</param>
            <returns>LEB128 bytes of value</returns>
        </member>
        <member name="T:EdjCase.ICP.Candid.Exceptions.CandidDecodingException">
            <summary>
            An error that occurs during the decoding of bytes to a candid structure
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Candid.Exceptions.CandidDecodingException.ByteEndIndex">
            <summary>
            The index where the byte reader last read. Helps identitfy the source of the 
            decoding issue
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Candid.Exceptions.CandidDecodingException.ErrorMessage">
            <summary>
            Message about the error that occurred
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Candid.Exceptions.CandidDecodingException.#ctor(System.Int32,System.String)">
            <param name="byteEndIndex">The index where the byte reader last read</param>
            <param name="message">Message about the error that occurred</param>
        </member>
        <member name="P:EdjCase.ICP.Candid.Exceptions.CandidDecodingException.Message">
            <inheritdoc/>
        </member>
        <member name="T:EdjCase.ICP.Candid.Exceptions.CandidTextParseException">
            <summary>
            An error that occurs when the conversion of text to a candid model fails
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Candid.Exceptions.CandidTextParseException.Message">
            <inheritdoc/>
        </member>
        <member name="T:EdjCase.ICP.Candid.Exceptions.InvalidCandidException">
            <summary>
            An error that occurs if the candid models do not follow the 
            specification
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Candid.Exceptions.InvalidCandidException.Message">
            <inheritdoc/>
        </member>
        <member name="T:EdjCase.ICP.Candid.Mapping.IObjectMapper">
            <summary>
            A custom mapper interface to map a C# type to and from a candid type
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Candid.Mapping.IObjectMapper.CandidType">
            <summary>
            Candid type to convert to/from
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Candid.Mapping.IObjectMapper.Type">
            <summary>
            C# type to convert to/from
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Candid.Mapping.IObjectMapper.Map(EdjCase.ICP.Candid.Models.Values.CandidValue,EdjCase.ICP.Candid.CandidConverterOptions)">
            <summary>
            Maps a candid value to a C# value.
            Input value will match the `CandidType` type property.
            Returned value should match the `Type` type property.
            </summary>
            <param name="value">Candid value to map to a C# value</param>
            <param name="options">Options that are being used for the mappings</param>
            <returns>C# value converted from the candid value</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Mapping.IObjectMapper.Map(System.Object,EdjCase.ICP.Candid.CandidConverterOptions)">
            <summary>
            Maps a C# value to a candid value and type.
            Input value will match the `Type` type property.
            Returned value should match the `CandidType` type property.
            </summary>
            <param name="value">C# value to map to a candid value</param>
            <param name="options">Options that are being used for the mappings</param>
            <returns>Candid value and type converted from the C# value</returns>
        </member>
        <member name="T:EdjCase.ICP.Candid.Mapping.CandidNameAttribute">
            <summary>
            An attribute to specify a candid name to use for serialization. If unspecified 
            the serializers will use the property names
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Candid.Mapping.CandidNameAttribute.Name">
            <summary>
            The name to use for serialization of candid values
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Candid.Mapping.CandidNameAttribute.#ctor(System.String)">
            <param name="name">The name to use for serialization of candid values</param>
        </member>
        <member name="T:EdjCase.ICP.Candid.Mapping.CustomMapperAttribute">
            <summary>
            An attribute that specifies a custom mapper for the class, struct, property or field
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Candid.Mapping.CustomMapperAttribute.Mapper">
            <summary>
            The object mapper to use for the decorated item
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Candid.Mapping.CustomMapperAttribute.#ctor(EdjCase.ICP.Candid.Mapping.IObjectMapper)">
            <param name="mapper">The object mapper to use for the decorated item</param>
        </member>
        <member name="T:EdjCase.ICP.Candid.Mapping.CandidIgnoreAttribute">
            <summary>
            An attribute to ignore a property/field of a class during serialization
            </summary>
        </member>
        <member name="T:EdjCase.ICP.Candid.Mapping.VariantAttribute">
            <summary>
            An attribute to put on a class to identify it as a variant type for serialization.
            Requires the use of `VariantTagPropertyAttribute`, `VariantOptionTypeAttribute` and
            `VariantValuePropertyAttribute` attributes if used
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Candid.Mapping.VariantAttribute.TagType">
            <summary>
            The enum type to use for specifying the tags of the variant
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Candid.Mapping.VariantAttribute.#ctor(System.Type)">
            <param name="enumType">The enum type to use for specifying the tags of the variant</param>
            <exception cref="T:System.ArgumentException">Throws if the type is not an enum</exception>
        </member>
        <member name="T:EdjCase.ICP.Candid.Mapping.VariantTagPropertyAttribute">
            <summary>
            An attribute to put on a property/field that indicates where to hold the 
            tag enum value. Must match the type passed to the `VariantAttribute`
            </summary>
        </member>
        <member name="T:EdjCase.ICP.Candid.Mapping.VariantValuePropertyAttribute">
            <summary>
            An attribute to put on a property/field that indicates where to hold the
            tag value object. The type must be compatible with all value types, recommend using `object?`
            </summary>
        </member>
        <member name="T:EdjCase.ICP.Candid.Mapping.VariantOptionTypeAttribute">
            <summary>
            An attribute to put on an enum option to specify if the tag has an attached
            value in the variant, otherwise the attached type will be null
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Candid.Mapping.VariantOptionTypeAttribute.OptionType">
            <summary>
            The type of the variant option value to use
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Candid.Mapping.VariantOptionTypeAttribute.#ctor(System.Type)">
            <param name="optionType">The type of the variant option value to use</param>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.CandidArg.ComputeHash(EdjCase.ICP.Candid.Crypto.IHashFunction)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.CandidArg.ToString">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.CandidArg.Equals(EdjCase.ICP.Candid.Models.CandidArg)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.CandidArg.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.CandidArg.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.CandidArg.op_Equality(EdjCase.ICP.Candid.Models.CandidArg,EdjCase.ICP.Candid.Models.CandidArg)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.CandidArg.op_Inequality(EdjCase.ICP.Candid.Models.CandidArg,EdjCase.ICP.Candid.Models.CandidArg)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.CandidId.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.CandidId.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.CandidId.Equals(EdjCase.ICP.Candid.Models.CandidId)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.CandidId.Equals(System.String)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.CandidId.op_Equality(EdjCase.ICP.Candid.Models.CandidId,EdjCase.ICP.Candid.Models.CandidId)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.CandidId.op_Inequality(EdjCase.ICP.Candid.Models.CandidId,EdjCase.ICP.Candid.Models.CandidId)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.CandidId.ToString">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.CandidId.CompareTo(EdjCase.ICP.Candid.Models.CandidId)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.CandidTag.HashName(System.String)">
            <summary>
            Hashes the name to get the proper id 
            hash(name) = ( Sum_(i=0..k) utf8(name)[i] * 223^(k-i) ) mod 2^32 where k = |utf8(name)|-1
            </summary>
            <param name="name">Name to hash</param>
            <returns>Unsigned 32 byte integer hash</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.CandidTypedValue.AsPrincipal">
            <summary>
            If opaque, returns null, otherwise the principalid
            </summary>
            <returns></returns>
        </member>
        <member name="F:EdjCase.ICP.Candid.Models.CompoundTypeTable.CompoundTypeIndexMap">
            <summary>
            A mapping of compound type definition to `EncodedCompoundTypes` index to be used as reference
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.HashTree.BuildRootHash">
            <summary>
            Computes the root SHA256 hash of the tree based on the IC certificate spec
            </summary>
            <returns>A blob of the hash digest</returns>
        </member>
        <member name="T:EdjCase.ICP.Candid.Models.Types.CandidKnownType">
            <summary>
            A candid type that is NOT a reference type. This type is known before any resolution
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Types.CandidKnownType.Type">
            <summary>
            The candid type that this model represents
            </summary>
        </member>
        <member name="T:EdjCase.ICP.Candid.Models.Types.CandidType">
            <summary>
            The base candid type model that all candid types inherit
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidType.Encode(EdjCase.ICP.Candid.Models.CompoundTypeTable)">
            <summary>
            Encodes this type into a byte array. If its a primitive type the value will
            be an encoded negative number, if its a compound type it will be added to the 
            type table and be a positive number of the table index where its info is stored
            </summary>
            <param name="compoundTypeTable">The collection of compound types for a candid arg</param>
            <returns>Byte array of the type number</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidType.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidType.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidType.ToString">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidType.Equals(EdjCase.ICP.Candid.Models.Types.CandidType)">
            <summary>
            Checks for equality of this type against the specified type
            </summary>
            <param name="other">Another type to compare against</param>
            <returns>True if they are structurally the same, otherwise false</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidType.op_Equality(EdjCase.ICP.Candid.Models.Types.CandidType,EdjCase.ICP.Candid.Models.Types.CandidType)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidType.op_Inequality(EdjCase.ICP.Candid.Models.Types.CandidType,EdjCase.ICP.Candid.Models.Types.CandidType)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidType.Text">
            <summary>
            Helper method to create a Text candid type
            </summary>
            <returns>Text candid type</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidType.Nat">
            <summary>
            Helper method to create a Nat candid type
            </summary>
            <returns>Nat candid type</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidType.Nat8">
            <summary>
            Helper method to create a Nat8 candid type
            </summary>
            <returns>Nat8 candid type</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidType.Nat16">
            <summary>
            Helper method to create a Nat16 candid type
            </summary>
            <returns>Nat16 candid type</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidType.Nat32">
            <summary>
            Helper method to create a Nat32 candid type
            </summary>
            <returns>Nat32 candid type</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidType.Nat64">
            <summary>
            Helper method to create a Nat64 candid type
            </summary>
            <returns>Nat64 candid type</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidType.Int">
            <summary>
            Helper method to create a Int candid type
            </summary>
            <returns>Int candid type</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidType.Int8">
            <summary>
            Helper method to create a Int8 candid type
            </summary>
            <returns>Int8 candid type</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidType.Int16">
            <summary>
            Helper method to create a Int16 candid type
            </summary>
            <returns>Int16 candid type</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidType.Int32">
            <summary>
            Helper method to create a Int32 candid type
            </summary>
            <returns>Int32 candid type</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidType.Int64">
            <summary>
            Helper method to create a Int64 candid type
            </summary>
            <returns>Int64 candid type</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidType.Float32">
            <summary>
            Helper method to create a Float32 candid type
            </summary>
            <returns>Float32 candid type</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidType.Float64">
            <summary>
            Helper method to create a Float64 candid type
            </summary>
            <returns>Float64 candid type</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidType.Bool">
            <summary>
            Helper method to create a Bool candid type
            </summary>
            <returns>Bool candid type</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidType.Principal">
            <summary>
            Helper method to create a Principal candid type
            </summary>
            <returns>Principal candid type</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidType.Null">
            <summary>
            Helper method to create a Null candid type
            </summary>
            <returns>Null candid type</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidType.Reserved">
            <summary>
            Helper method to create a Reserved candid type
            </summary>
            <returns>Reserved candid type</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidType.Empty">
            <summary>
            Helper method to create a Empty candid type
            </summary>
            <returns>Empty candid type</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidType.Opt(EdjCase.ICP.Candid.Models.Types.CandidType)">
            <summary>
            Helper method to create a Opt candid type
            </summary>
            <returns>Opt candid type</returns>
        </member>
        <member name="T:EdjCase.ICP.Candid.Models.Types.CandidCompoundType">
            <summary>
            A candid type that is not primitive or a reference. These types are considered
            more complex and have multiple data structures within them
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Types.CandidCompoundType.RecursiveId">
            <summary>
            Optional. Used if this type can be referenced by an inner type recursively.
            The inner type will use `CandidReferenceType` with this id
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidCompoundType.#ctor(EdjCase.ICP.Candid.Models.CandidId)">
            <param name="recursiveId">Optional. Used if this type can be referenced by an inner type recursively.
            The inner type will use `CandidReferenceType` with this id</param>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidCompoundType.EncodeInnerTypes(EdjCase.ICP.Candid.Models.CompoundTypeTable)">
            <summary>
            Adds all inner types to the compound table if applicable and returns its encoded type value
            </summary>
            <param name="compoundTypeTable">The collection of compound types for a candid arg</param>
            <returns>Byte array of encoded type</returns>
        </member>
        <member name="T:EdjCase.ICP.Candid.Models.Types.CandidRecordOrVariantType">
            <summary>
            A shared class for candid records and variants. Both have a mapping of 
            keys with associated types
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Types.CandidRecordOrVariantType.Type">
            <inheritdoc />
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Types.CandidRecordOrVariantType.TypeString">
            <summary>
            The string name of the parent type (record or variant)
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidRecordOrVariantType.GetFieldsOrOptions">
            <summary>
            Gets the record fields or variant options to be used for encoding
            </summary>
            <returns></returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidRecordOrVariantType.#ctor(EdjCase.ICP.Candid.Models.CandidId)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidRecordOrVariantType.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidRecordOrVariantType.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:EdjCase.ICP.Candid.Models.Types.FuncMode">
            <summary>
            All the possible options for function modes which
            define special attributes of the function
            </summary>
        </member>
        <member name="F:EdjCase.ICP.Candid.Models.Types.FuncMode.Oneway">
            <summary>
            Mode where the function does not generate a response to a request
            </summary>
        </member>
        <member name="F:EdjCase.ICP.Candid.Models.Types.FuncMode.Query">
            <summary>
            Mode where the function does not update any state and returns immediately.
            Is useful for faster data retrieval
            </summary>
        </member>
        <member name="T:EdjCase.ICP.Candid.Models.Types.CandidFuncType">
            <summary>
            A candid type model that defines a func
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Types.CandidFuncType.Type">
            <inheritdoc />
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Types.CandidFuncType.Modes">
            <summary>
            A set of different modes the function supports
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Types.CandidFuncType.ArgTypes">
            <summary>
            A list of all the argument types the function will need in a request.
            The name is optional and is only used for ease of use, the index/position
            of the argument is all that really matters
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Types.CandidFuncType.ReturnTypes">
            <summary>
            A list of all the return types the function will supply in respose to a request.
            The name is optional and is only used for ease of use, the index/position
            of the argument is all that really matters
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidFuncType.#ctor(System.Collections.Generic.List{EdjCase.ICP.Candid.Models.Types.FuncMode},System.Collections.Generic.List{EdjCase.ICP.Candid.Models.Types.CandidType},System.Collections.Generic.List{EdjCase.ICP.Candid.Models.Types.CandidType},EdjCase.ICP.Candid.Models.CandidId)">
            <param name="modes">A set of different modes the function supports</param>
            <param name="argTypes">A list of all the argument types the function will need in a request.
            The name is optional and is only used for ease of use, the index/position
            of the argument is all that really matters</param>
            <param name="returnTypes">A list of all the return types the function will supply in respose to a request.
            The name is optional and is only used for ease of use, the index/position
            of the argument is all that really matters</param>
            <param name="recursiveId">Optional. Used if this type can be referenced by an inner type recursively.
            The inner type will use `CandidReferenceType` with this id</param>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidFuncType.#ctor(System.Collections.Generic.List{EdjCase.ICP.Candid.Models.Types.FuncMode},System.Collections.Generic.List{System.ValueTuple{EdjCase.ICP.Candid.Models.CandidId,EdjCase.ICP.Candid.Models.Types.CandidType}},System.Collections.Generic.List{System.ValueTuple{EdjCase.ICP.Candid.Models.CandidId,EdjCase.ICP.Candid.Models.Types.CandidType}},EdjCase.ICP.Candid.Models.CandidId)">
            <param name="modes">A set of different modes the function supports</param>
            <param name="argTypes">A list of all the argument types the function will need in a request.
            The name is optional and is only used for ease of use, the index/position
            of the argument is all that really matters</param>
            <param name="returnTypes">A list of all the return types the function will supply in respose to a request.
            The name is optional and is only used for ease of use, the index/position
            of the argument is all that really matters</param>
            <param name="recursiveId">Optional. Used if this type can be referenced by an inner type recursively.
            The inner type will use `CandidReferenceType` with this id</param>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidFuncType.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidFuncType.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:EdjCase.ICP.Candid.Models.Types.CandidOptionalType">
            <summary>
            A model for candid optional types
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Types.CandidOptionalType.Type">
            <inheritdoc />
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Types.CandidOptionalType.Value">
            <summary>
            The inner value type of the optional value, if the value is not null
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidOptionalType.#ctor(EdjCase.ICP.Candid.Models.Types.CandidType,EdjCase.ICP.Candid.Models.CandidId)">
            <param name="value">The inner value type of the optional value, if the value is not null</param>
            <param name="recursiveId">Optional. Used if this type can be referenced by an inner type recursively.
            The inner type will use `CandidReferenceType` with this id</param>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidOptionalType.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidOptionalType.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidPrimitiveType.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidPrimitiveType.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:EdjCase.ICP.Candid.Models.Types.CandidRecordType">
            <summary>
            A model for candid record types
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Types.CandidRecordType.Type">
            <inheritdoc />
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Types.CandidRecordType.TypeString">
            <inheritdoc />
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Types.CandidRecordType.Fields">
            <summary>
            The collection of field names with the associate type for that field
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidRecordType.#ctor(System.Collections.Generic.Dictionary{EdjCase.ICP.Candid.Models.CandidTag,EdjCase.ICP.Candid.Models.Types.CandidType},EdjCase.ICP.Candid.Models.CandidId)">
            <param name="fields">The collection of field names with the associate type for that field</param>
            <param name="recursiveId">Optional. Used if this type can be referenced by an inner type recursively.
            The inner type will use `CandidReferenceType` with this id</param>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidRecordType.GetFieldsOrOptions">
            <inheritdoc />
        </member>
        <member name="T:EdjCase.ICP.Candid.Models.Types.CandidReferenceType">
            <summary>
            A special candid type model that is a pointer to a different type.
            Usually due to recursive types where a parent type has an inner type
            that references that same parent type. The parent type must have a `RecursiveId`
            specified and the `Id` of the reference type must match that
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Types.CandidReferenceType.Id">
            <summary>
            The id to reference in a parent type. The parent type must have the `RecursiveId` specified
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidReferenceType.#ctor(EdjCase.ICP.Candid.Models.CandidId)">
            <param name="id">The id to reference in a parent type. The parent type must have the `RecursiveId` specified</param>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidReferenceType.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidReferenceType.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:EdjCase.ICP.Candid.Models.Types.CandidServiceType">
            <summary>
            A model for a candid service type
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Types.CandidServiceType.Type">
            <inheritdoc />
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Types.CandidServiceType.Methods">
            <summary>
            A mapping of ids to function types that the service contains
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidServiceType.#ctor(System.Collections.Generic.Dictionary{EdjCase.ICP.Candid.Models.CandidId,EdjCase.ICP.Candid.Models.Types.CandidFuncType},EdjCase.ICP.Candid.Models.CandidId)">
            <param name="methods">A mapping of ids to function types that the service contains</param>
            <param name="recursiveId">Optional. Used if this type can be referenced by an inner type recursively.
            The inner type will use `CandidReferenceType` with this id</param>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidServiceType.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidServiceType.GetHashCode">
            <inheritdoc />
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Types.CandidVariantType.Type">
            <inheritdoc />
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Types.CandidVectorType.Type">
            <inheritdoc />
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Types.CandidVectorType.InnerType">
            <summary>
            The type of the vectors inner values
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidVectorType.#ctor(EdjCase.ICP.Candid.Models.Types.CandidType,EdjCase.ICP.Candid.Models.CandidId)">
            <param name="innerType">The type of the vectors inner values</param>
            <param name="recursiveId">Optional. Used if this type can be referenced by an inner type recursively.
            The inner type will use `CandidReferenceType` with this id</param>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidVectorType.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidVectorType.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:EdjCase.ICP.Candid.Models.Values.CandidFunc">
            <summary>
            A model to represent the value of a candid func
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Values.CandidFunc.Type">
            <inheritdoc />
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Values.CandidFunc.IsOpaqueReference">
            <summary>
            True if the candid func definition is an opaque (non standard/system specific definition),
            otherwise false
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidFunc.#ctor(EdjCase.ICP.Candid.Models.Values.CandidService,System.String)">
            <param name="service">The candid service definition the function lives in</param>
            <param name="name">The name of the function</param>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidFunc.EncodeValue(EdjCase.ICP.Candid.Models.Types.CandidType,System.Func{EdjCase.ICP.Candid.Models.CandidId,EdjCase.ICP.Candid.Models.Types.CandidCompoundType})">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidFunc.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidFunc.Equals(EdjCase.ICP.Candid.Models.Values.CandidValue)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidFunc.ToString">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidFunc.OpaqueReference">
            <summary>
            Creates an opaque reference to a function that is defined by the system
            vs being defined in candid
            </summary>
            <returns>A opaque candid func</returns>
        </member>
        <member name="T:EdjCase.ICP.Candid.Models.Values.CandidOptional">
            <summary>
            A model representing the value of a candid opt
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Values.CandidOptional.Type">
            <inheritdoc />
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Values.CandidOptional.Value">
            <summary>
            The inner value of an opt. If not set, will be a candid null value
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidOptional.#ctor(EdjCase.ICP.Candid.Models.Values.CandidValue)">
            <param name="value">The inner value of an opt. If not set, will be a candid null value</param>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidOptional.EncodeValue(EdjCase.ICP.Candid.Models.Types.CandidType,System.Func{EdjCase.ICP.Candid.Models.CandidId,EdjCase.ICP.Candid.Models.Types.CandidCompoundType})">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidOptional.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidOptional.Equals(EdjCase.ICP.Candid.Models.Values.CandidValue)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidOptional.ToString">
            <inheritdoc />
        </member>
        <member name="T:EdjCase.ICP.Candid.Models.Values.PrimitiveType">
            <summary>
            All the candid primitive types
            </summary>
        </member>
        <member name="F:EdjCase.ICP.Candid.Models.Values.PrimitiveType.Text">
            <summary>
            A text/string value
            </summary>
        </member>
        <member name="F:EdjCase.ICP.Candid.Models.Values.PrimitiveType.Nat">
            <summary>
            A unbounded unsigned integer (natural number)
            </summary>
        </member>
        <member name="F:EdjCase.ICP.Candid.Models.Values.PrimitiveType.Nat8">
            <summary>
            A 8-bit unsigned integer (natural number)
            </summary>
        </member>
        <member name="F:EdjCase.ICP.Candid.Models.Values.PrimitiveType.Nat16">
            <summary>
            A 16-bit unsigned integer (natural number)
            </summary>
        </member>
        <member name="F:EdjCase.ICP.Candid.Models.Values.PrimitiveType.Nat32">
            <summary>
            A 32-bit unsigned integer (natural number)
            </summary>
        </member>
        <member name="F:EdjCase.ICP.Candid.Models.Values.PrimitiveType.Nat64">
            <summary>
            A 64-bit unsigned integer (natural number)
            </summary>
        </member>
        <member name="F:EdjCase.ICP.Candid.Models.Values.PrimitiveType.Int">
            <summary>
            A unbounded integer
            </summary>
        </member>
        <member name="F:EdjCase.ICP.Candid.Models.Values.PrimitiveType.Int8">
            <summary>
            A 8-bit integer
            </summary>
        </member>
        <member name="F:EdjCase.ICP.Candid.Models.Values.PrimitiveType.Int16">
            <summary>
            A 16-bit integer
            </summary>
        </member>
        <member name="F:EdjCase.ICP.Candid.Models.Values.PrimitiveType.Int32">
            <summary>
            A 32-bit integer
            </summary>
        </member>
        <member name="F:EdjCase.ICP.Candid.Models.Values.PrimitiveType.Int64">
            <summary>
            A 64-bit integer
            </summary>
        </member>
        <member name="F:EdjCase.ICP.Candid.Models.Values.PrimitiveType.Float32">
            <summary>
            A 32-bit floating point number
            </summary>
        </member>
        <member name="F:EdjCase.ICP.Candid.Models.Values.PrimitiveType.Float64">
            <summary>
            A 64-bit floating point number
            </summary>
        </member>
        <member name="F:EdjCase.ICP.Candid.Models.Values.PrimitiveType.Bool">
            <summary>
            A boolean (true/false) value
            </summary>
        </member>
        <member name="F:EdjCase.ICP.Candid.Models.Values.PrimitiveType.Principal">
            <summary>
            A candid principal value which works as an identifier for identities/canisters
            </summary>
        </member>
        <member name="F:EdjCase.ICP.Candid.Models.Values.PrimitiveType.Reserved">
            <summary>
            A 'any' type value that is a supertype of all types. It allows the removal of a type without breaking
            the type structure
            </summary>
        </member>
        <member name="F:EdjCase.ICP.Candid.Models.Values.PrimitiveType.Empty">
            <summary>
            A value with no data that is considered a subtype of all types. Practical use cases for the empty type are relatively rare.
            </summary>
        </member>
        <member name="F:EdjCase.ICP.Candid.Models.Values.PrimitiveType.Null">
            <summary>
            The null value that is a supertype of any `opt t` value
            </summary>
        </member>
        <member name="T:EdjCase.ICP.Candid.Models.Values.CandidPrimitive">
            <summary>
            A model representing a candid primitive type
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Values.CandidPrimitive.Type">
            <inheritdoc />
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Values.CandidPrimitive.ValueType">
            <summary>
            The specific primitive type that is represented
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidPrimitive.AsText">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidPrimitive.AsNat">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidPrimitive.AsNat8">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidPrimitive.AsNat16">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidPrimitive.AsNat32">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidPrimitive.AsNat64">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidPrimitive.AsInt">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidPrimitive.AsInt8">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidPrimitive.AsInt16">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidPrimitive.AsInt32">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidPrimitive.AsInt64">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidPrimitive.AsFloat32">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidPrimitive.AsFloat64">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidPrimitive.AsBool">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidPrimitive.AsPrincipal">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidPrimitive.EncodeValue(EdjCase.ICP.Candid.Models.Types.CandidType,System.Func{EdjCase.ICP.Candid.Models.CandidId,EdjCase.ICP.Candid.Models.Types.CandidCompoundType})">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidPrimitive.ToString">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidPrimitive.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidPrimitive.Equals(EdjCase.ICP.Candid.Models.Values.CandidValue)">
            <inheritdoc />
        </member>
        <member name="T:EdjCase.ICP.Candid.Models.Values.CandidRecord">
            <summary>
            A model representing a candid record
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Values.CandidRecord.Type">
            <inheritdoc />
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Values.CandidRecord.Fields">
            <summary>
            The mapping of field name to field value for the record
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidRecord.#ctor(System.Collections.Generic.Dictionary{EdjCase.ICP.Candid.Models.CandidTag,EdjCase.ICP.Candid.Models.Values.CandidValue})">
            <param name="fields">The mapping of field name to field value for the record</param>
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Values.CandidRecord.Item(System.String)">
            <summary>
            Gets the candid value of the field with the specified name
            </summary>
            <param name="name">Name of the field value to get, case sensitive</param>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Throws if field name is not found</exception>
            <returns>The field value</returns>
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Values.CandidRecord.Item(System.UInt32)">
            <summary>
            Gets the candid value of the field with the specified id (name hash)
            </summary>
            <param name="id">Id (name hash) of the field value to get</param>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Throws if field id is not found</exception>
            <returns>The field value</returns>
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Values.CandidRecord.Item(EdjCase.ICP.Candid.Models.CandidTag)">
            <summary>
            Gets the candid value of the field with the specified tag
            </summary>
            <param name="tag">Tag of the field value to get</param>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Throws if field tag is not found</exception>
            <returns>The field value</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidRecord.TryGetField(System.String,EdjCase.ICP.Candid.Models.Values.CandidValue@)">
            <summary>
            Tries to get the field based on the specified name. If the field does not exist, will return false,
            otherwise true. The out value will only be set if returns true, otherwise value will be null
            </summary>
            <param name="name">Name of the field value to get, case sensitive</param>
            <param name="value">Out value that is set only if the method returns true</param>
            <returns>True if field exists, otherwise false</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidRecord.TryGetField(System.UInt32,EdjCase.ICP.Candid.Models.Values.CandidValue@)">
            <summary>
            Tries to get the field based on the specified id (name hash). If the field does not exist, will return false,
            otherwise true. The out value will only be set if returns true, otherwise value will be null
            </summary>
            <param name="id">Id (name hash) of the field value to get</param>
            <param name="value">Out value that is set only if the method returns true</param>
            <returns>True if field exists, otherwise false</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidRecord.TryGetField(EdjCase.ICP.Candid.Models.CandidTag,EdjCase.ICP.Candid.Models.Values.CandidValue@)">
            <summary>
            Tries to get the field based on the specified tag. If the field does not exist, will return false,
            otherwise true. The out value will only be set if returns true, otherwise value will be null
            </summary>
            <param name="tag">Tag of the field value to get</param>
            <param name="value">Out value that is set only if the method returns true</param>
            <returns>True if field exists, otherwise false</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidRecord.FromDictionary(System.Collections.Generic.Dictionary{System.String,EdjCase.ICP.Candid.Models.Values.CandidValue})">
            <summary>
            Helper method to create a record value from a dictionary of field names to values
            </summary>
            <param name="fields">Dictionary of field names to values for the record</param>
            <returns>A candid record from the fields specified</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidRecord.FromDictionary(System.Collections.Generic.Dictionary{System.UInt32,EdjCase.ICP.Candid.Models.Values.CandidValue})">
            <summary>
            Helper method to create a record value from a dictionary of field ids (name hashes) to values
            </summary>
            <param name="fields">Dictionary of ids (name hashes) to values for the record</param>
            <returns>A candid record from the fields specified</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidRecord.FromDictionary(System.Collections.Generic.Dictionary{EdjCase.ICP.Candid.Models.CandidTag,EdjCase.ICP.Candid.Models.Values.CandidValue})">
            <summary>
            Helper method to create a record value from a dictionary of field tags to values
            </summary>
            <param name="fields">Dictionary of tags to values for the record</param>
            <returns>A candid record from the fields specified</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidRecord.EncodeValue(EdjCase.ICP.Candid.Models.Types.CandidType,System.Func{EdjCase.ICP.Candid.Models.CandidId,EdjCase.ICP.Candid.Models.Types.CandidCompoundType})">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidRecord.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidRecord.Equals(EdjCase.ICP.Candid.Models.Values.CandidValue)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidRecord.ToString">
            <inheritdoc />
        </member>
        <member name="T:EdjCase.ICP.Candid.Models.Values.CandidService">
            <summary>
            A model that represents a candid service value
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Values.CandidService.Type">
            <inheritdoc />
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Values.CandidService.IsOpqaueReference">
            <summary>
            True if the candid func definition is an opaque (non standard/system specific definition),
            otherwise false
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidService.#ctor(EdjCase.ICP.Candid.Models.Principal)">
            <param name="principalId">The id of the canister where the service lives</param>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidService.GetPrincipal">
            <summary>
            Gets the prinicipal of the candid service. If it is an opaque reference, then an exception will
            be thrown
            </summary>
            <returns>Pricipal of the candid service</returns>
            <exception cref="T:System.InvalidOperationException">Throws if service is an opaque reference</exception>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidService.EncodeValue(EdjCase.ICP.Candid.Models.Types.CandidType,System.Func{EdjCase.ICP.Candid.Models.CandidId,EdjCase.ICP.Candid.Models.Types.CandidCompoundType})">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidService.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidService.Equals(EdjCase.ICP.Candid.Models.Values.CandidValue)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidService.ToString">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidService.OpaqueReference">
            <summary>
            Helper method to create an opaque service reference where the id/location 
            of the service is non-standard/system specific
            </summary>
            <returns></returns>
        </member>
        <member name="T:EdjCase.ICP.Candid.Models.Values.CandidValueType">
            <summary>
            The options for candid value types
            </summary>
        </member>
        <member name="F:EdjCase.ICP.Candid.Models.Values.CandidValueType.Primitive">
            <summary>
            Primitive/simple candid types like nat, int, null, etc...
            </summary>
        </member>
        <member name="F:EdjCase.ICP.Candid.Models.Values.CandidValueType.Vector">
            <summary>
            An array of values
            </summary>
        </member>
        <member name="F:EdjCase.ICP.Candid.Models.Values.CandidValueType.Record">
            <summary>
            A value with a set of fields, each with a name/id and value
            </summary>
        </member>
        <member name="F:EdjCase.ICP.Candid.Models.Values.CandidValueType.Variant">
            <summary>
            A value with a chosen option name/id and value
            </summary>
        </member>
        <member name="F:EdjCase.ICP.Candid.Models.Values.CandidValueType.Func">
            <summary>
            A function located in a service
            </summary>
        </member>
        <member name="F:EdjCase.ICP.Candid.Models.Values.CandidValueType.Service">
            <summary>
            A location with a set of functions to call
            </summary>
        </member>
        <member name="F:EdjCase.ICP.Candid.Models.Values.CandidValueType.Optional">
            <summary>
            A value that is either null or a value
            </summary>
        </member>
        <member name="F:EdjCase.ICP.Candid.Models.Values.CandidValueType.Principal">
            <summary>
            An identifier value used for canister ids and identity ids
            </summary>
        </member>
        <member name="T:EdjCase.ICP.Candid.Models.Values.CandidValue">
            <summary>
            The base class for all candid value
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Values.CandidValue.Type">
            <summary>
            The type of candid value is implemented
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidValue.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidValue.Equals(EdjCase.ICP.Candid.Models.Values.CandidValue)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidValue.ToString">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidValue.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidValue.op_Equality(EdjCase.ICP.Candid.Models.Values.CandidValue,EdjCase.ICP.Candid.Models.Values.CandidValue)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidValue.op_Inequality(EdjCase.ICP.Candid.Models.Values.CandidValue,EdjCase.ICP.Candid.Models.Values.CandidValue)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidValue.AsPrimitive">
            <summary>
            Casts the candid value to a primitive type. If the type is not primitive, will throw an exception
            </summary>
            <exception cref="T:System.InvalidOperationException">Throws if the type is not primitive</exception>
            <returns>A primitive value</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidValue.AsVector">
            <summary>
            Casts the candid value to a vector type. If the type is not vector, will throw an exception
            </summary>
            <exception cref="T:System.InvalidOperationException">Throws if the type is not vector</exception>
            <returns>A vector value</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidValue.AsVectorAsList``1(System.Func{EdjCase.ICP.Candid.Models.Values.CandidValue,``0})">
            <summary>
            Casts the candid value to a vector type and maps it to a List. If the type is not vector,
            will throw an exception
            </summary>
            <param name="converter">The conversion function from candid value to T</param>
            <exception cref="T:System.InvalidOperationException">Throws if the type is not vector</exception>
            <returns>A list form of the vector</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidValue.AsVectorAsArray``1(System.Func{EdjCase.ICP.Candid.Models.Values.CandidValue,``0})">
            <summary>
            Casts the candid value to a vector type and maps it to an array. If the type is not vector,
            will throw an exception
            </summary>
            <param name="converter">The conversion function from candid value to T</param>
            <exception cref="T:System.InvalidOperationException">Throws if the type is not vector</exception>
            <returns>An array form of the vector</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidValue.IsNull">
            <summary>
            Checks if the value is null
            </summary>
            <returns>Returns true if the value is null, otherwise false</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidValue.AsRecord">
            <summary>
            Casts the candid value to a record type. If the type is not record, will throw an exception
            </summary>
            <exception cref="T:System.InvalidOperationException">Throws if the type is not record</exception>
            <returns>A record value</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidValue.AsPrincipal">
            <summary>
            If opaque, returns null, otherwise the principalid
            </summary>
            <returns></returns>
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Values.CandidVariant.Type">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidVariant.EncodeValue(EdjCase.ICP.Candid.Models.Types.CandidType,System.Func{EdjCase.ICP.Candid.Models.CandidId,EdjCase.ICP.Candid.Models.Types.CandidCompoundType})">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidVariant.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidVariant.Equals(EdjCase.ICP.Candid.Models.Values.CandidValue)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidVariant.ToString">
            <inheritdoc />
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Values.CandidVector.Type">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidVector.EncodeValue(EdjCase.ICP.Candid.Models.Types.CandidType,System.Func{EdjCase.ICP.Candid.Models.CandidId,EdjCase.ICP.Candid.Models.Types.CandidCompoundType})">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidVector.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidVector.Equals(EdjCase.ICP.Candid.Models.Values.CandidValue)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidVector.ToString">
            <inheritdoc />
        </member>
        <member name="T:EdjCase.ICP.Candid.Parsers.CandidByteParser">
            <summary>
            Functions to help parse candid arguments from the raw bytes
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Candid.Parsers.CandidByteParser.Parse(System.Byte[])">
            <summary>
            Converts a byte representation of candid arguments to a usable model
            </summary>
            <param name="value">The byte representation of Candid arguments</param>
            <returns>Candid arg value from the specified bytes</returns>
            <exception cref="T:EdjCase.ICP.Candid.Exceptions.CandidDecodingException">Throws if the bytes are not valid Candid</exception>
            <exception cref="T:EdjCase.ICP.Candid.Exceptions.InvalidCandidException">Throws if the the candid does not follow the specification</exception>
            $"Candid failed with while resolving a type reference
        </member>
        <member name="T:System.Runtime.CompilerServices.IsExternalInit">
            <summary>
            Reserved to be used by the compiler for tracking metadata.
            This class should not be used by developers in source code.
            </summary>
        </member>
    </members>
</doc>
