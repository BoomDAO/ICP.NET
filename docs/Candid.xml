<?xml version="1.0"?>
<doc>
    <assembly>
        <name>EdjCase.ICP.Candid</name>
    </assembly>
    <members>
        <member name="M:EdjCase.ICP.Candid.BinarySequence.#ctor(System.Boolean[])">
            <param name="bits">Least signifcant to most ordered bits</param>
        </member>
        <member name="F:EdjCase.ICP.Candid.CandidArgBuilder.compoundTypeTable">
            <summary>
            Helper to capture compound types
            </summary>
        </member>
        <member name="F:EdjCase.ICP.Candid.CandidArgBuilder.EncodedTypes">
            <summary>
            Ordered list of encoded types (encoded with SLEB128).
            If SLEB value is positive, it is an index for `EncodedCompoundTypes` for a compound type
            If SLEB value is negative, it is type code for a primitive value
            </summary>
        </member>
        <member name="F:EdjCase.ICP.Candid.CandidArgBuilder.EncodedValues">
            <summary>
            Ordered list of encoded values
            </summary>
        </member>
        <member name="T:EdjCase.ICP.Candid.Crypto.CRC32">
            <summary>
            Helper class for computing CRC32 hashes/checksums on byte data
            Useful for calculating checksums on data
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Candid.Crypto.CRC32.ComputeHash(System.IO.Stream)">
            <summary>
            Computes the 32-bit hash on the stream of data provided
            </summary>
            <param name="stream">Byte data. Will use the whole stream</param>
            <returns>Hash of the byte data as a byte array of length of 4</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Crypto.CRC32.ComputeHash(System.Byte[])">
            <summary>
            Computes the 32-bit hash on the data bytes provided
            </summary>
            <param name="data">Byte data</param>
            <returns>Hash of the byte data as a byte array of length of 4</returns>
        </member>
        <member name="T:EdjCase.ICP.Candid.Crypto.IHashFunction">
            <summary>
            Interface to implement different hash function algorithms against
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Candid.Crypto.IHashFunction.ComputeHash(System.Byte[])">
            <summary>
            Computes the hash of the byte array based on the algorithm implemented
            </summary>
            <param name="value">Byte array to get the hash of</param>
            <returns>Hash in the form of a byte array</returns>
        </member>
        <member name="T:EdjCase.ICP.Candid.Crypto.SHA256HashFunction">
            <summary>
            A SHA256 implementation of the `IHashFunction`
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Candid.Crypto.SHA256HashFunction.ComputeHash(System.Byte[])">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Crypto.SHA256HashFunction.Create">
            <summary>
            Helper method to create the hash function object
            </summary>
            <returns>Hash function object</returns>
        </member>
        <member name="T:EdjCase.ICP.Candid.Encodings.LEB128">
            <summary>
            Utility class to provide methods for LEB128 encoding (https://en.wikipedia.org/wiki/LEB128)
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Candid.Encodings.LEB128.DecodeUnsigned(System.Byte[])">
            <summary>
            Takes a byte encoded unsigned LEB128 and converts it to an `UnboundedUInt`
            </summary>
            <param name="encodedValue">Byte value of an unsigned LEB128</param>
            <returns>`UnboundedUInt` of LEB128 value</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Encodings.LEB128.DecodeUnsigned(System.IO.Stream)">
            <summary>
            Takes a encoded unsigned LEB128 byte stream and converts it to an `UnboundedUInt`
            </summary>
            <param name="stream">Byte stream of an unsigned LEB128</param>
            <returns>`UnboundedUInt` of LEB128 value</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Encodings.LEB128.DecodeSigned(System.IO.Stream)">
            <summary>
            Takes a encoded signed LEB128 byte stream and converts it to an `UnboundedInt`
            </summary>
            <param name="stream">Byte stream of a signed LEB128</param>
            <returns>`UnboundedInt` of LEB128 value</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Encodings.LEB128.EncodeUnsigned(EdjCase.ICP.Candid.Models.UnboundedUInt)">
            <summary>
            Takes an `UnboundedUInt` and converts it into an encoded unsigned LEB128 byte array
            </summary>
            <param name="value">Value to convert to LEB128 bytes</param>
            <returns>LEB128 bytes of value</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Encodings.LEB128.EncodeSigned(EdjCase.ICP.Candid.Models.UnboundedInt)">
            <summary>
            Takes an `UnboundedInt` and converts it into an encoded signed LEB128 byte array
            </summary>
            <param name="value">Value to convert to LEB128 bytes</param>
            <returns>LEB128 bytes of value</returns>
        </member>
        <member name="T:EdjCase.ICP.Candid.Exceptions.CandidDecodingException">
            <summary>
            An error that occurs during the decoding of bytes to a candid structure
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Candid.Exceptions.CandidDecodingException.ByteEndIndex">
            <summary>
            The index where the byte reader last read. Helps identitfy the source of the 
            decoding issue
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Candid.Exceptions.CandidDecodingException.ErrorMessage">
            <summary>
            Message about the error that occurred
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Candid.Exceptions.CandidDecodingException.#ctor(System.Int32,System.String)">
            <param name="byteEndIndex">The index where the byte reader last read</param>
            <param name="message">Message about the error that occurred</param>
        </member>
        <member name="P:EdjCase.ICP.Candid.Exceptions.CandidDecodingException.Message">
            <inheritdoc/>
        </member>
        <member name="T:EdjCase.ICP.Candid.Exceptions.CandidTextParseException">
            <summary>
            An error that occurs when the conversion of text to a candid model fails
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Candid.Exceptions.CandidTextParseException.Message">
            <inheritdoc/>
        </member>
        <member name="T:EdjCase.ICP.Candid.Exceptions.InvalidCandidException">
            <summary>
            An error that occurs if the candid models do not follow the 
            specification
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Candid.Exceptions.InvalidCandidException.Message">
            <inheritdoc/>
        </member>
        <member name="T:EdjCase.ICP.Candid.Mapping.IObjectMapper">
            <summary>
            A custom mapper interface to map a C# type to and from a candid type
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Candid.Mapping.IObjectMapper.CandidType">
            <summary>
            Candid type to convert to/from
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Candid.Mapping.IObjectMapper.Type">
            <summary>
            C# type to convert to/from
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Candid.Mapping.IObjectMapper.Map(EdjCase.ICP.Candid.Models.Values.CandidValue,EdjCase.ICP.Candid.CandidConverterOptions)">
            <summary>
            Maps a candid value to a C# value.
            Input value will match the `CandidType` type property.
            Returned value should match the `Type` type property.
            </summary>
            <param name="value">Candid value to map to a C# value</param>
            <param name="options">Options that are being used for the mappings</param>
            <returns>C# value converted from the candid value</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Mapping.IObjectMapper.Map(System.Object,EdjCase.ICP.Candid.CandidConverterOptions)">
            <summary>
            Maps a C# value to a candid value and type.
            Input value will match the `Type` type property.
            Returned value should match the `CandidType` type property.
            </summary>
            <param name="value">C# value to map to a candid value</param>
            <param name="options">Options that are being used for the mappings</param>
            <returns>Candid value and type converted from the C# value</returns>
        </member>
        <member name="T:EdjCase.ICP.Candid.Mapping.CandidNameAttribute">
            <summary>
            An attribute to specify a candid name to use for serialization. If unspecified 
            the serializers will use the property names
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Candid.Mapping.CandidNameAttribute.Name">
            <summary>
            The name to use for serialization of candid values
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Candid.Mapping.CandidNameAttribute.#ctor(System.String)">
            <param name="name">The name to use for serialization of candid values</param>
        </member>
        <member name="T:EdjCase.ICP.Candid.Mapping.CustomMapperAttribute">
            <summary>
            An attribute that specifies a custom mapper for the class, struct, property or field
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Candid.Mapping.CustomMapperAttribute.Mapper">
            <summary>
            The object mapper to use for the decorated item
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Candid.Mapping.CustomMapperAttribute.#ctor(EdjCase.ICP.Candid.Mapping.IObjectMapper)">
            <param name="mapper">The object mapper to use for the decorated item</param>
        </member>
        <member name="T:EdjCase.ICP.Candid.Mapping.CandidIgnoreAttribute">
            <summary>
            An attribute to ignore a property/field of a class during serialization
            </summary>
        </member>
        <member name="T:EdjCase.ICP.Candid.Mapping.VariantAttribute">
            <summary>
            An attribute to put on a class to identify it as a variant type for serialization.
            Requires the use of `VariantTagPropertyAttribute`, `VariantOptionTypeAttribute` and
            `VariantValuePropertyAttribute` attributes if used
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Candid.Mapping.VariantAttribute.TagType">
            <summary>
            The enum type to use for specifying the tags of the variant
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Candid.Mapping.VariantAttribute.#ctor(System.Type)">
            <param name="enumType">The enum type to use for specifying the tags of the variant</param>
            <exception cref="T:System.ArgumentException">Throws if the type is not an enum</exception>
        </member>
        <member name="T:EdjCase.ICP.Candid.Mapping.VariantTagPropertyAttribute">
            <summary>
            An attribute to put on a property/field that indicates where to hold the 
            tag enum value. Must match the type passed to the `VariantAttribute`
            </summary>
        </member>
        <member name="T:EdjCase.ICP.Candid.Mapping.VariantValuePropertyAttribute">
            <summary>
            An attribute to put on a property/field that indicates where to hold the
            tag value object. The type must be compatible with all value types, recommend using `object?`
            </summary>
        </member>
        <member name="T:EdjCase.ICP.Candid.Mapping.VariantOptionTypeAttribute">
            <summary>
            An attribute to put on an enum option to specify if the tag has an attached
            value in the variant, otherwise the attached type will be null
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Candid.Mapping.VariantOptionTypeAttribute.OptionType">
            <summary>
            The type of the variant option value to use
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Candid.Mapping.VariantOptionTypeAttribute.#ctor(System.Type)">
            <param name="optionType">The type of the variant option value to use</param>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.CandidTag.HashName(System.String)">
            <summary>
            Hashes the name to get the proper id 
            hash(name) = ( Sum_(i=0..k) utf8(name)[i] * 223^(k-i) ) mod 2^32 where k = |utf8(name)|-1
            </summary>
            <param name="name">Name to hash</param>
            <returns>Unsigned 32 byte integer hash</returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.CandidTypedValue.AsPrincipal">
            <summary>
            If opaque, returns null, otherwise the principalid
            </summary>
            <returns></returns>
        </member>
        <member name="F:EdjCase.ICP.Candid.Models.CompoundTypeTable.CompoundTypeIndexMap">
            <summary>
            A mapping of compound type definition to `EncodedCompoundTypes` index to be used as reference
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.HashTree.BuildRootHash">
            <summary>
            Computes the root SHA256 hash of the tree based on the IC certificate spec
            </summary>
            <returns>A blob of the hash digest</returns>
        </member>
        <member name="T:EdjCase.ICP.Candid.Models.Types.CandidKnownType">
            <summary>
            A candid type that is NOT a reference type. This type is known before any resolution
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Candid.Models.Types.CandidKnownType.Type">
            <summary>
            The candid type that this model represents
            </summary>
        </member>
        <member name="T:EdjCase.ICP.Candid.Models.Types.CandidType">
            <summary>
            The base candid type model that all candid types inherit
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidType.Encode(EdjCase.ICP.Candid.Models.CompoundTypeTable)">
            <summary>
            Encodes this type into a byte array 
            </summary>
            <param name="compoundTypeTable"></param>
            <returns></returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidType.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidType.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Types.CandidType.ToString">
            <inheritdoc />
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidPrimitive.AsPrincipal">
            <summary>
            If opaque, returns null, otherwise the principalid
            </summary>
            <returns></returns>
        </member>
        <member name="M:EdjCase.ICP.Candid.Models.Values.CandidValue.AsPrincipal">
            <summary>
            If opaque, returns null, otherwise the principalid
            </summary>
            <returns></returns>
        </member>
        <member name="T:EdjCase.ICP.Candid.Parsers.CandidByteParser">
            <summary>
            Functions to help parse candid arguments from the raw bytes
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Candid.Parsers.CandidByteParser.Parse(System.Byte[])">
            <summary>
            Converts a byte representation of candid arguments to a usable model
            </summary>
            <param name="value">The byte representation of Candid arguments</param>
            <returns>Candid arg value from the specified bytes</returns>
            <exception cref="T:EdjCase.ICP.Candid.Exceptions.CandidDecodingException">Throws if the bytes are not valid Candid</exception>
            <exception cref="T:EdjCase.ICP.Candid.Exceptions.InvalidCandidException">Throws if the the candid does not follow the specification</exception>
            $"Candid failed with while resolving a type reference
        </member>
        <member name="T:System.Runtime.CompilerServices.IsExternalInit">
            <summary>
            Reserved to be used by the compiler for tracking metadata.
            This class should not be used by developers in source code.
            </summary>
        </member>
    </members>
</doc>
