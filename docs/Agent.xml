<?xml version="1.0"?>
<doc>
    <assembly>
        <name>EdjCase.ICP.Agent</name>
    </assembly>
    <members>
        <member name="T:EdjCase.ICP.Agent.Agents.HttpAgent">
            <summary>
            An `IAgent` implementation using HTTP to make requests to the IC
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Agent.Agents.HttpAgent.Identity">
            <summary>
            The identity that will be used on each request unless overriden
            This identity can be anonymous
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Agent.Agents.HttpAgent.#ctor(EdjCase.ICP.Agent.Identities.IIdentity,System.Uri)">
            <param name="identity">Identity to use for each request. Can be anonymous</param>
            <param name="httpBoundryNodeUrl">Url to the boundry node to connect to. Defaults to `https://ic0.app/`</param>
        </member>
        <member name="M:EdjCase.ICP.Agent.Agents.HttpAgent.CallAsync(EdjCase.ICP.Candid.Models.Principal,System.String,EdjCase.ICP.Candid.Models.CandidArg,EdjCase.ICP.Candid.Models.Principal,EdjCase.ICP.Agent.Identities.IIdentity)">
            <inheritdoc cref="M:EdjCase.ICP.Agent.Agents.IAgent.CallAsync(EdjCase.ICP.Candid.Models.Principal,System.String,EdjCase.ICP.Candid.Models.CandidArg,EdjCase.ICP.Candid.Models.Principal,EdjCase.ICP.Agent.Identities.IIdentity)"/>
        </member>
        <member name="M:EdjCase.ICP.Agent.Agents.HttpAgent.QueryAsync(EdjCase.ICP.Candid.Models.Principal,System.String,EdjCase.ICP.Candid.Models.CandidArg,EdjCase.ICP.Agent.Identities.IIdentity)">
            <inheritdoc cref="M:EdjCase.ICP.Agent.Agents.IAgent.QueryAsync(EdjCase.ICP.Candid.Models.Principal,System.String,EdjCase.ICP.Candid.Models.CandidArg,EdjCase.ICP.Agent.Identities.IIdentity)"/>
        </member>
        <member name="M:EdjCase.ICP.Agent.Agents.HttpAgent.ReadStateAsync(EdjCase.ICP.Candid.Models.Principal,System.Collections.Generic.List{EdjCase.ICP.Candid.Models.StatePath},EdjCase.ICP.Agent.Identities.IIdentity)">
            <inheritdoc cref="M:EdjCase.ICP.Agent.Agents.IAgent.ReadStateAsync(EdjCase.ICP.Candid.Models.Principal,System.Collections.Generic.List{EdjCase.ICP.Candid.Models.StatePath},EdjCase.ICP.Agent.Identities.IIdentity)"/>
        </member>
        <member name="M:EdjCase.ICP.Agent.Agents.HttpAgent.GetRequestStatusAsync(EdjCase.ICP.Candid.Models.Principal,EdjCase.ICP.Candid.Models.RequestId)">
            <inheritdoc cref="M:EdjCase.ICP.Agent.Agents.IAgent.GetRequestStatusAsync(EdjCase.ICP.Candid.Models.Principal,EdjCase.ICP.Candid.Models.RequestId)"/>
        </member>
        <member name="M:EdjCase.ICP.Agent.Agents.HttpAgent.GetRootKeyAsync">
            <inheritdoc cref="M:EdjCase.ICP.Agent.Agents.IAgent.GetRootKeyAsync"/>
        </member>
        <member name="M:EdjCase.ICP.Agent.Agents.HttpAgent.GetReplicaStatusAsync">
            <inheritdoc cref="M:EdjCase.ICP.Agent.Agents.IAgent.GetReplicaStatusAsync"/>
        </member>
        <member name="T:EdjCase.ICP.Agent.Agents.IAgent">
            <summary>
            An agent is used to communicate with the Internet Computer with certain protocols that 
            are specific to an `IAgent` implementation
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Agent.Agents.IAgent.ReadStateAsync(EdjCase.ICP.Candid.Models.Principal,System.Collections.Generic.List{EdjCase.ICP.Candid.Models.StatePath},EdjCase.ICP.Agent.Identities.IIdentity)">
            <summary>
            Gets the state of a specified canister with the subset of state information
            specified by the paths parameter
            </summary>
            <param name="canisterId">Canister to read state for</param>
            <param name="paths">The state paths to get information for. Other state data will be pruned if not specified</param>
            <param name="identityOverride">Optional. If specified, will override the agent identity</param>
            <returns>A response that contains the certificate of the current cansiter state</returns>
        </member>
        <member name="M:EdjCase.ICP.Agent.Agents.IAgent.GetRequestStatusAsync(EdjCase.ICP.Candid.Models.Principal,EdjCase.ICP.Candid.Models.RequestId)">
            <summary>
            Gets the status of a request that is being processed by the specified canister
            </summary>
            <param name="canisterId">Canister where the request was sent to</param>
            <param name="id">Id of the request to get a status for</param>
            <returns>A status variant of the request. If request is not found, will return null</returns>
        </member>
        <member name="M:EdjCase.ICP.Agent.Agents.IAgent.CallAsync(EdjCase.ICP.Candid.Models.Principal,System.String,EdjCase.ICP.Candid.Models.CandidArg,EdjCase.ICP.Candid.Models.Principal,EdjCase.ICP.Agent.Identities.IIdentity)">
            <summary>
            Sends a call request to a specified canister method and gets back an id of the 
            request that is being processed. This call does NOT wait for the request to be complete.
            Either check the status with `GetRequestStatusAsync` or use the `CallAndWaitAsync` method
            </summary>
            <param name="canisterId">Canister to read state for</param>
            <param name="method">The name of the method to call on the cansiter</param>
            <param name="arg">The candid arg to send with the request</param>
            <param name="effectiveCanisterId">Optional. Specifies the relevant canister id if calling the root canister</param>
            <param name="identityOverride">Optional. If specified, will override the agent identity</param>
            <returns>The id of the request that can be used to look up its status with `GetRequestStatusAsync`</returns>
        </member>
        <member name="M:EdjCase.ICP.Agent.Agents.IAgent.GetReplicaStatusAsync">
            <summary>
            Gets the status of the IC replica. This includes versioning information
            about the replica
            </summary>
            <returns>A response containing all replica status information</returns>
        </member>
        <member name="M:EdjCase.ICP.Agent.Agents.IAgent.QueryAsync(EdjCase.ICP.Candid.Models.Principal,System.String,EdjCase.ICP.Candid.Models.CandidArg,EdjCase.ICP.Agent.Identities.IIdentity)">
            <summary>
            Sends a query request to a specified canister method
            </summary>
            <param name="canisterId">Canister to read state for</param>
            <param name="method">The name of the method to call on the cansiter</param>
            <param name="arg">The candid arg to send with the request</param>
            <param name="identityOverride">Optional. If specified, will override the agent identity</param>
            <returns>The response data of the query call</returns>
        </member>
        <member name="M:EdjCase.ICP.Agent.Agents.IAgent.GetRootKeyAsync">
            <summary>
            Gets the root public key of the current Internet Computer network
            </summary>
            <returns>The root public key bytes </returns>
        </member>
        <member name="T:EdjCase.ICP.Agent.Agents.IAgentExtensions">
            <summary>
            Extension methods for the `IAgent` interface
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Agent.Agents.IAgentExtensions.CallAndWaitAsync(EdjCase.ICP.Agent.Agents.IAgent,EdjCase.ICP.Candid.Models.Principal,System.String,EdjCase.ICP.Candid.Models.CandidArg,EdjCase.ICP.Candid.Models.Principal,EdjCase.ICP.Agent.Identities.IIdentity,System.Nullable{System.Threading.CancellationToken})">
            <summary>
            Sends a call request to a specified canister method, waits for the request to be processed,
            the returns the candid response to the call. This is helper method built on top of `CallAsync`
            to wait for the response so it doesn't need to be implemented manually
            </summary>
            <param name="agent">The agent to use for the call</param>
            <param name="canisterId">Canister to read state for</param>
            <param name="method">The name of the method to call on the cansiter</param>
            <param name="arg">The candid arg to send with the request</param>
            <param name="effectiveCanisterId">Optional. Specifies the relevant canister id if calling the root canister</param>
            <param name="identityOverride">Optional. If specified, will override the agent identity</param>
            <param name="cancellationToken">Optional. If specified, will be used to prematurely end the waiting</param>
            <returns>The id of the request that can be used to look up its status with `GetRequestStatusAsync`</returns>
        </member>
        <member name="T:EdjCase.ICP.Agent.RequestCleanedUpException">
            <summary>
            Exception to indicate that a request has been cleaned up.
            This is usually due to the request being too old
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Agent.RequestCleanedUpException.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="T:EdjCase.ICP.Agent.InvalidPublicKey">
            <summary>
            Exception to indicate that the specified BLS public key is invalid
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Agent.InvalidPublicKey.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="T:EdjCase.ICP.Agent.InvalidCertificateException">
            <summary>
            Exception to indicate that the certificate is invalid
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Agent.InvalidCertificateException.#ctor(System.String)">
            <param name="message">Specific error message</param>
        </member>
        <member name="T:EdjCase.ICP.Agent.Identities.AnonymousIdentity">
            <summary>
            An identity that is anonymous.
            Should be used if there is no user context or the user hasn't logged in
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Agent.Identities.AnonymousIdentity.SignContent(System.Collections.Generic.Dictionary{System.String,EdjCase.ICP.Candid.Models.IHashable})">
            <inheritdoc/>
        </member>
        <member name="M:EdjCase.ICP.Agent.Identities.AnonymousIdentity.GetPrincipal">
            <inheritdoc/>
        </member>
        <member name="M:EdjCase.ICP.Agent.Identities.DelegationIdentity.GetPublicKey">
            <inheritdoc/>
        </member>
        <member name="M:EdjCase.ICP.Agent.Identities.DelegationIdentity.Sign(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:EdjCase.ICP.Agent.Identities.DelegationIdentity.GetSenderDelegations">
            <inheritdoc/>
        </member>
        <member name="T:EdjCase.ICP.Agent.Identities.Ed25519Identity">
            <summary>
            An identity using a Ed25519 key
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Agent.Identities.Ed25519Identity.PublicKey">
            <summary>
            The public key of the identity
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Agent.Identities.Ed25519Identity.PrivateKey">
            <summary>
            The private key of the identity
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Agent.Identities.Ed25519Identity.#ctor(EdjCase.ICP.Agent.Keys.Ed25519PublicKey,System.Byte[])">
            <param name="publicKey">The public key of the identity</param>
            <param name="privateKey">The private key of the identity</param>
        </member>
        <member name="M:EdjCase.ICP.Agent.Identities.Ed25519Identity.GetPublicKey">
            <inheritdoc/>
        </member>
        <member name="M:EdjCase.ICP.Agent.Identities.Ed25519Identity.Sign(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="T:EdjCase.ICP.Agent.Identities.IIdentity">
            <summary>
            Identity to use for requests to Internet Computer canisters
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Agent.Identities.IIdentity.GetPrincipal">
            <summary>
            Gets the principal for this identity
            </summary>
            <returns>The identity principal</returns>
        </member>
        <member name="M:EdjCase.ICP.Agent.Identities.IIdentity.SignContent(System.Collections.Generic.Dictionary{System.String,EdjCase.ICP.Candid.Models.IHashable})">
            <summary>
            Signs the hashable content
            </summary>
            <param name="content">The data that needs to be signed</param>
            <returns>The content with signature(s) from the identity</returns>
        </member>
        <member name="T:EdjCase.ICP.Agent.Identities.SigningIdentityBase">
            <summary>
            An identity type that has signing capabilities
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Agent.Identities.SigningIdentityBase.GetPublicKey">
            <summary>
            Returns the public key of the identity
            </summary>
            <returns>Public key of the identity</returns>
        </member>
        <member name="M:EdjCase.ICP.Agent.Identities.SigningIdentityBase.GetSenderDelegations">
            <summary>
            Gets the signed delegations for the identity.
            Delegations will exist if the identity is a delegated identity
            instead of having the raw keys. This is used in Internet Identity
            </summary>
            <returns>The signed delegations, otherwise an empty list</returns>
        </member>
        <member name="M:EdjCase.ICP.Agent.Identities.SigningIdentityBase.Sign(System.Byte[])">
            <summary>
            Signs the specified bytes with the identity key
            </summary>
            <param name="data">The byte data to sign</param>
            <returns>The signature bytes of the specified data bytes</returns>
        </member>
        <member name="M:EdjCase.ICP.Agent.Identities.SigningIdentityBase.GetPrincipal">
            <inheritdoc/>
        </member>
        <member name="M:EdjCase.ICP.Agent.Identities.SigningIdentityBase.SignContent(System.Collections.Generic.Dictionary{System.String,EdjCase.ICP.Candid.Models.IHashable})">
            <inheritdoc/>
        </member>
        <member name="T:EdjCase.ICP.Agent.Keys.BlsPublicKey">
            <summary>
            A public key using the BLS algorithm
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Agent.Keys.BlsPublicKey.Value">
            <summary>
            The raw bytes value
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Agent.Keys.BlsPublicKey.#ctor(System.Byte[])">
            <param name="value">The raw bytes value</param>
        </member>
        <member name="M:EdjCase.ICP.Agent.Keys.BlsPublicKey.ComputeHash(EdjCase.ICP.Candid.Crypto.IHashFunction)">
            <inheritdoc/>
        </member>
        <member name="M:EdjCase.ICP.Agent.Keys.BlsPublicKey.GetDerEncodedBytes">
            <inheritdoc/>
        </member>
        <member name="M:EdjCase.ICP.Agent.Keys.BlsPublicKey.FromDer(System.Byte[])">
            <summary>
            Converts a DER encoded public key into a public key object
            </summary>
            <param name="derEncodedPublicKey">Public key with a DER encoding</param>
            <returns>Key object from the specified public key</returns>
        </member>
        <member name="M:EdjCase.ICP.Agent.Keys.BlsPublicKey.GetRawBytes">
            <summary>
            Gets the raw bytes of the public key
            </summary>
            <returns>Public key bytes</returns>
        </member>
        <member name="M:EdjCase.ICP.Agent.Keys.BlsPublicKey.ValidateSignature(System.Byte[],System.Byte[])">
            <summary>
            Validates the specified signature against the specified hash value
            </summary>
            <param name="hash">The hash digest of some data</param>
            <param name="signature">The signature for the hashed data</param>
            <returns>True if the signature is valid, otherwise false</returns>
        </member>
        <member name="T:EdjCase.ICP.Agent.Keys.Ed25519PublicKey">
            <summary>
            A public key using the Ed25519 algorithm
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Agent.Keys.Ed25519PublicKey.Value">
            <summary>
            The raw key bytes
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Agent.Keys.Ed25519PublicKey.#ctor(System.Byte[])">
            <param name="value">The raw key bytes</param>
            <exception cref="T:System.ArgumentNullException">Throws if the value is null</exception>
        </member>
        <member name="M:EdjCase.ICP.Agent.Keys.Ed25519PublicKey.ComputeHash(EdjCase.ICP.Candid.Crypto.IHashFunction)">
            <summary>
            Computes the hash of the key with the specified hash function
            </summary>
            <param name="hashFunction">A hash function to hash the key with</param>
            <returns>The hash of the key bytes</returns>
        </member>
        <member name="M:EdjCase.ICP.Agent.Keys.Ed25519PublicKey.GetRawBytes">
            <summary>
            The raw bytes of the key
            </summary>
            <returns></returns>
        </member>
        <member name="M:EdjCase.ICP.Agent.Keys.Ed25519PublicKey.GetDerEncodedBytes">
            <summary>
            The bytes of the key with DER encoding
            </summary>
            <returns>DER encoded key bytes</returns>
        </member>
        <member name="M:EdjCase.ICP.Agent.Keys.Ed25519PublicKey.FromDer(System.Byte[])">
            <summary>
            Builds a key from the DER encoded bytes
            </summary>
            <param name="derEncodedPublicKey">The DER encoded bytes of the key</param>
            <returns>A decoded key</returns>
            <exception cref="T:EdjCase.ICP.Agent.InvalidPublicKey">Throws if the key bytes is invalid</exception>
        </member>
        <member name="T:EdjCase.ICP.Agent.Keys.IPublicKey">
            <summary>
            A cryptographic public key that can be DER encoded
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Agent.Keys.IPublicKey.GetDerEncodedBytes">
            <summary>
            Gets the DER encoded bytes of the key
            </summary>
            <returns>DER encoded key bytes</returns>
        </member>
        <member name="M:EdjCase.ICP.Agent.Keys.IPublicKey.GetRawBytes">
            <summary>
            Gets the raw bytes of the key
            </summary>
            <returns>Key bytes</returns>
        </member>
        <member name="T:EdjCase.ICP.Agent.Models.Certificate">
            <summary>
            A model that contains a state tree along with a validation signature. If required
            the model can have a delegation to allow for subnet data/keys
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Agent.Models.Certificate.Tree">
            <summary>
            A partial state tree of the requested state data
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Agent.Models.Certificate.Signature">
            <summary>
            A signature on the tree root hash. Used to validate the tree
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Agent.Models.Certificate.Delegation">
            <summary>
            Optional. A signed delegation that links a public key to the root public key
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Agent.Models.Certificate.#ctor(EdjCase.ICP.Candid.Models.HashTree,System.Byte[],EdjCase.ICP.Agent.Models.CertificateDelegation)">
            <param name="tree">A partial state tree of the requested state data</param>
            <param name="signature">A signature on the tree root hash. Used to validate the tree</param>
            <param name="delegation">Optional. A signed delegation that links a public key to the root public key</param>
            <exception cref="T:System.ArgumentNullException">Throws if either `tree` or `signature` are null</exception>
        </member>
        <member name="M:EdjCase.ICP.Agent.Models.Certificate.IsValid(System.Byte[])">
            <summary>
            Checks the validity of the certificate based off the 
            specified root public key
            </summary>
            <param name="rootPublicKey">The root public key of the internet computer network</param>
            <returns>True if the certificate is valid, otherwise false</returns>
        </member>
        <member name="T:EdjCase.ICP.Agent.Models.CertificateDelegation">
            <summary>
            A model that contains a certificate proving the delegation of a subnet for the subnet certificate
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Agent.Models.CertificateDelegation.SubnetId">
            <summary>
            The principal of the subnet being delegated to
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Agent.Models.CertificateDelegation.Certificate">
            <summary>
            The signed certificate that is signed by the delegator
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Agent.Models.CertificateDelegation.#ctor(EdjCase.ICP.Candid.Models.Principal,EdjCase.ICP.Agent.Models.Certificate)">
            <param name="subnetId">The principal of the subnet being delegated to</param>
            <param name="certificate">The signed certificate that is signed by the delegator</param>
            <exception cref="T:System.ArgumentNullException">Throws if either `subnetId` or `certificate` are null</exception>
        </member>
        <member name="M:EdjCase.ICP.Agent.Models.CertificateDelegation.GetPublicKey">
            <summary>
            Gets the public key value from the hash tree in the certificate
            </summary>
            <returns>The delegation public key for the subnet</returns>
            <exception cref="T:System.InvalidOperationException">Throws if certificate is missing `subnet/{subnet_id}/public_key`</exception>
        </member>
        <member name="M:EdjCase.ICP.Agent.Models.CertificateDelegation.IsValid(System.Byte[]@)">
            <summary>
            Checks if the Certificate signature is valid and
            outputs the public key of the delegation
            </summary>
            <param name="publicKey">The public key of the delegation</param>
            <returns>True if the certificate signature is valid, otherwise false</returns>
        </member>
        <member name="P:EdjCase.ICP.Agent.Requests.CallRequest.CanisterId">
            <summary>
            The principal of the canister to call
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Agent.Requests.CallRequest.Method">
            <summary>
            Name of the canister method to call
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Agent.Requests.CallRequest.Arg">
            <summary>
            Argument to pass to the canister method
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Agent.Requests.CallRequest.Sender">
            <summary>
            The user who issued the request
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Agent.Requests.CallRequest.IngressExpiry">
            <summary>
            An upper limit on the validity of the request, expressed in nanoseconds since 1970-01-01
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Agent.Requests.CallRequest.Nonce">
            <summary>
            Optional. Arbitrary user-provided data, typically randomly generated. This can be used to create distinct requests with otherwise identical fields.
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Agent.Requests.QueryRequest.CanisterId">
            <summary>
            The principal of the canister to call.
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Agent.Requests.QueryRequest.Method">
            <summary>
            Name of the canister method to call
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Agent.Requests.QueryRequest.EncodedArgument">
            <summary>
            Argument to pass to the canister method
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Agent.Requests.QueryRequest.Sender">
            <summary>
            Required. The user who issued the request.
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Agent.Requests.QueryRequest.IngressExpiry">
            <summary>
            Required.  An upper limit on the validity of the request, expressed in nanoseconds since 
            1970-01-01 (like ic0.time()). This avoids replay attacks: The IC will not accept requests, 
            or transition requests from status received to status processing, if their expiry date is in 
            the past. The IC may refuse to accept requests with an ingress expiry date too far in the future. 
            This applies to synchronous and asynchronous requests alike (and could have been called request_expiry).
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Agent.Requests.QueryRequest.Nonce">
            <summary>
            Optional. Arbitrary user-provided data, typically randomly generated. 
            This can be used to create distinct requests with otherwise identical fields.
            </summary>
        </member>
    </members>
</doc>
