<?xml version="1.0"?>
<doc>
    <assembly>
        <name>EdjCase.ICP.Agent</name>
    </assembly>
    <members>
        <member name="T:EdjCase.ICP.Agent.Agents.HttpAgent">
            <summary>
            An `IAgent` implementation using HTTP to make requests to the IC
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Agent.Agents.HttpAgent.Identity">
            <summary>
            The identity that will be used on each request unless overriden
            This identity can be anonymous
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Agent.Agents.HttpAgent.#ctor(EdjCase.ICP.Agent.Identities.IIdentity,System.Uri)">
            <param name="identity">Optional. Identity to use for each request. If unspecified, will use anonymous identity</param>
            <param name="httpBoundryNodeUrl">Url to the boundry node to connect to. Defaults to `https://ic0.app/`</param>
        </member>
        <member name="M:EdjCase.ICP.Agent.Agents.HttpAgent.CallAsync(EdjCase.ICP.Candid.Models.Principal,System.String,EdjCase.ICP.Candid.Models.CandidArg,EdjCase.ICP.Candid.Models.Principal)">
            <inheritdoc/>
        </member>
        <member name="M:EdjCase.ICP.Agent.Agents.HttpAgent.QueryAsync(EdjCase.ICP.Candid.Models.Principal,System.String,EdjCase.ICP.Candid.Models.CandidArg)">
            <inheritdoc/>
        </member>
        <member name="M:EdjCase.ICP.Agent.Agents.HttpAgent.ReadStateAsync(EdjCase.ICP.Candid.Models.Principal,System.Collections.Generic.List{EdjCase.ICP.Candid.Models.StatePath})">
            <inheritdoc/>
        </member>
        <member name="M:EdjCase.ICP.Agent.Agents.HttpAgent.GetRequestStatusAsync(EdjCase.ICP.Candid.Models.Principal,EdjCase.ICP.Candid.Models.RequestId)">
            <inheritdoc/>
        </member>
        <member name="M:EdjCase.ICP.Agent.Agents.HttpAgent.GetRootKeyAsync">
            <inheritdoc/>
        </member>
        <member name="M:EdjCase.ICP.Agent.Agents.HttpAgent.GetReplicaStatusAsync">
            <inheritdoc/>
        </member>
        <member name="T:EdjCase.ICP.Agent.Agents.IAgent">
            <summary>
            An agent is used to communicate with the Internet Computer with certain protocols that 
            are specific to an `IAgent` implementation
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Agent.Agents.IAgent.Identity">
            <summary>
            The identity to use for requests. If null, then it will use the anonymous identity
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Agent.Agents.IAgent.ReadStateAsync(EdjCase.ICP.Candid.Models.Principal,System.Collections.Generic.List{EdjCase.ICP.Candid.Models.StatePath})">
            <summary>
            Gets the state of a specified canister with the subset of state information
            specified by the paths parameter
            </summary>
            <param name="canisterId">Canister to read state for</param>
            <param name="paths">The state paths to get information for. Other state data will be pruned if not specified</param>
            <returns>A response that contains the certificate of the current cansiter state</returns>
        </member>
        <member name="M:EdjCase.ICP.Agent.Agents.IAgent.GetRequestStatusAsync(EdjCase.ICP.Candid.Models.Principal,EdjCase.ICP.Candid.Models.RequestId)">
            <summary>
            Gets the status of a request that is being processed by the specified canister
            </summary>
            <param name="canisterId">Canister where the request was sent to</param>
            <param name="id">Id of the request to get a status for</param>
            <returns>A status variant of the request. If request is not found, will return null</returns>
        </member>
        <member name="M:EdjCase.ICP.Agent.Agents.IAgent.CallAsync(EdjCase.ICP.Candid.Models.Principal,System.String,EdjCase.ICP.Candid.Models.CandidArg,EdjCase.ICP.Candid.Models.Principal)">
            <summary>
            Sends a call request to a specified canister method and gets back an id of the 
            request that is being processed. This call does NOT wait for the request to be complete.
            Either check the status with `GetRequestStatusAsync` or use the `CallAndWaitAsync` method
            </summary>
            <param name="canisterId">Canister to read state for</param>
            <param name="method">The name of the method to call on the cansiter</param>
            <param name="arg">The candid arg to send with the request</param>
            <param name="effectiveCanisterId">Optional. Specifies the relevant canister id if calling the root canister</param>
            <returns>The id of the request that can be used to look up its status with `GetRequestStatusAsync`</returns>
        </member>
        <member name="M:EdjCase.ICP.Agent.Agents.IAgent.GetReplicaStatusAsync">
            <summary>
            Gets the status of the IC replica. This includes versioning information
            about the replica
            </summary>
            <returns>A response containing all replica status information</returns>
        </member>
        <member name="M:EdjCase.ICP.Agent.Agents.IAgent.QueryAsync(EdjCase.ICP.Candid.Models.Principal,System.String,EdjCase.ICP.Candid.Models.CandidArg)">
            <summary>
            Sends a query request to a specified canister method
            </summary>
            <param name="canisterId">Canister to read state for</param>
            <param name="method">The name of the method to call on the cansiter</param>
            <param name="arg">The candid arg to send with the request</param>
            <returns>The response data of the query call</returns>
        </member>
        <member name="M:EdjCase.ICP.Agent.Agents.IAgent.GetRootKeyAsync">
            <summary>
            Gets the root public key of the current Internet Computer network
            </summary>
            <returns>The root public key bytes </returns>
        </member>
        <member name="T:EdjCase.ICP.Agent.Agents.IAgentExtensions">
            <summary>
            Extension methods for the `IAgent` interface
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Agent.Agents.IAgentExtensions.CallAndWaitAsync(EdjCase.ICP.Agent.Agents.IAgent,EdjCase.ICP.Candid.Models.Principal,System.String,EdjCase.ICP.Candid.Models.CandidArg,EdjCase.ICP.Candid.Models.Principal,System.Nullable{System.Threading.CancellationToken})">
            <summary>
            Sends a call request to a specified canister method, waits for the request to be processed,
            the returns the candid response to the call. This is helper method built on top of `CallAsync`
            to wait for the response so it doesn't need to be implemented manually
            </summary>
            <param name="agent">The agent to use for the call</param>
            <param name="canisterId">Canister to read state for</param>
            <param name="method">The name of the method to call on the cansiter</param>
            <param name="arg">The candid arg to send with the request</param>
            <param name="effectiveCanisterId">Optional. Specifies the relevant canister id if calling the root canister</param>
            <param name="cancellationToken">Optional. If specified, will be used to prematurely end the waiting</param>
            <returns>The id of the request that can be used to look up its status with `GetRequestStatusAsync`</returns>
        </member>
        <member name="T:EdjCase.ICP.Agent.RequestCleanedUpException">
            <summary>
            Exception to indicate that a request has been cleaned up.
            This is usually due to the request being too old
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Agent.RequestCleanedUpException.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="T:EdjCase.ICP.Agent.InvalidPublicKey">
            <summary>
            Exception to indicate that the specified BLS public key is invalid
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Agent.InvalidPublicKey.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="T:EdjCase.ICP.Agent.InvalidCertificateException">
            <summary>
            Exception to indicate that the certificate is invalid
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Agent.InvalidCertificateException.#ctor(System.String)">
            <param name="message">Specific error message</param>
        </member>
        <member name="T:EdjCase.ICP.Agent.Identities.DelegationIdentity">
            <summary>
            An identity that has a signed delegation chain that authorizes
            the identity to act as another identity
            
            This is commonly used for things like Internet Identity where
            a login session always generates a new key but that key has been 
            signed by an authorized device through internet identity
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Agent.Identities.DelegationIdentity.Identity">
            <summary>
            The identity that authorization has been delegated to
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Agent.Identities.DelegationIdentity.Chain">
            <summary>
            The chain of singed delegations that prove authorization of the identity
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Agent.Identities.DelegationIdentity.#ctor(EdjCase.ICP.Agent.Identities.IIdentity,EdjCase.ICP.Agent.Models.DelegationChain)">
            <param name="identity">The identity that authorization has been delegated to</param>
            <param name="chain">The chain of singed delegations that prove authorization of the identity</param>
        </member>
        <member name="M:EdjCase.ICP.Agent.Identities.DelegationIdentity.GetPublicKey">
            <inheritdoc/>
        </member>
        <member name="M:EdjCase.ICP.Agent.Identities.DelegationIdentity.SignAsync(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:EdjCase.ICP.Agent.Identities.DelegationIdentity.GetSenderDelegations">
            <inheritdoc/>
        </member>
        <member name="T:EdjCase.ICP.Agent.Identities.Ed25519Identity">
            <summary>
            An identity using a Ed25519 key
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Agent.Identities.Ed25519Identity.PublicKey">
            <summary>
            The public key of the identity
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Agent.Identities.Ed25519Identity.PrivateKey">
            <summary>
            The private key of the identity
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Agent.Identities.Ed25519Identity.#ctor(EdjCase.ICP.Agent.DerEncodedPublicKey,System.Byte[])">
            <param name="publicKey">The public key of the identity</param>
            <param name="privateKey">The private key of the identity</param>
        </member>
        <member name="M:EdjCase.ICP.Agent.Identities.Ed25519Identity.GetPublicKey">
            <inheritdoc/>
        </member>
        <member name="M:EdjCase.ICP.Agent.Identities.Ed25519Identity.SignAsync(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:EdjCase.ICP.Agent.Identities.Ed25519Identity.GetSenderDelegations">
            <inheritdoc/>
        </member>
        <member name="M:EdjCase.ICP.Agent.Identities.Ed25519Identity.Generate">
            <summary>
            Generates an identity with a new Ed25519 key pair
            </summary>
            <returns>A Ed25519 identity</returns>
        </member>
        <member name="T:EdjCase.ICP.Agent.Identities.IIdentity">
            <summary>
            Identity to use for requests to Internet Computer canisters
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Agent.Identities.IIdentity.GetPublicKey">
            <summary>
            Returns the public key of the identity
            </summary>
            <returns>Public key of the identity</returns>
        </member>
        <member name="M:EdjCase.ICP.Agent.Identities.IIdentity.GetSenderDelegations">
            <summary>
            Gets the signed delegations for the identity.
            Delegations will exist if the identity is a delegated identity
            instead of having the raw keys. This is used in Internet Identity
            </summary>
            <returns>The signed delegations, otherwise an empty list</returns>
        </member>
        <member name="M:EdjCase.ICP.Agent.Identities.IIdentity.SignAsync(System.Byte[])">
            <summary>
            Signs the specified bytes with the identity key
            </summary>
            <param name="data">The byte data to sign</param>
            <returns>The signature bytes of the specified data bytes</returns>
        </member>
        <member name="T:EdjCase.ICP.Agent.Identities.IIdentityExtensions">
            <summary>
            Extension methods for the IIdentity interface
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Agent.Identities.IIdentityExtensions.SignContentAsync(EdjCase.ICP.Agent.Identities.IIdentity,System.Collections.Generic.Dictionary{System.String,EdjCase.ICP.Candid.Models.IHashable})">
            <summary>
            Signs the hashable content
            </summary>
            <param name="identity">The identity to sign the content with</param>
            <param name="content">The data that needs to be signed</param>
            <returns>The content with signature(s) from the identity</returns>
        </member>
        <member name="T:EdjCase.ICP.Agent.Models.Certificate">
            <summary>
            A model that contains a state tree along with a validation signature. If required
            the model can have a delegation to allow for subnet data/keys
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Agent.Models.Certificate.Tree">
            <summary>
            A partial state tree of the requested state data
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Agent.Models.Certificate.Signature">
            <summary>
            A signature on the tree root hash. Used to validate the tree
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Agent.Models.Certificate.Delegation">
            <summary>
            Optional. A signed delegation that links a public key to the root public key
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Agent.Models.Certificate.#ctor(EdjCase.ICP.Candid.Models.HashTree,System.Byte[],EdjCase.ICP.Agent.Models.CertificateDelegation)">
            <param name="tree">A partial state tree of the requested state data</param>
            <param name="signature">A signature on the tree root hash. Used to validate the tree</param>
            <param name="delegation">Optional. A signed delegation that links a public key to the root public key</param>
            <exception cref="T:System.ArgumentNullException">Throws if either `tree` or `signature` are null</exception>
        </member>
        <member name="M:EdjCase.ICP.Agent.Models.Certificate.IsValid(System.Byte[])">
            <summary>
            Checks the validity of the certificate based off the 
            specified root public key
            </summary>
            <param name="rootPublicKey">The root public key of the internet computer network</param>
            <returns>True if the certificate is valid, otherwise false</returns>
        </member>
        <member name="T:EdjCase.ICP.Agent.Models.CertificateDelegation">
            <summary>
            A model that contains a certificate proving the delegation of a subnet for the subnet certificate
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Agent.Models.CertificateDelegation.SubnetId">
            <summary>
            The principal of the subnet being delegated to
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Agent.Models.CertificateDelegation.Certificate">
            <summary>
            The signed certificate that is signed by the delegator
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Agent.Models.CertificateDelegation.#ctor(EdjCase.ICP.Candid.Models.Principal,EdjCase.ICP.Agent.Models.Certificate)">
            <param name="subnetId">The principal of the subnet being delegated to</param>
            <param name="certificate">The signed certificate that is signed by the delegator</param>
            <exception cref="T:System.ArgumentNullException">Throws if either `subnetId` or `certificate` are null</exception>
        </member>
        <member name="M:EdjCase.ICP.Agent.Models.CertificateDelegation.GetPublicKey">
            <summary>
            Gets the public key value from the hash tree in the certificate
            </summary>
            <returns>The delegation public key for the subnet</returns>
            <exception cref="T:System.InvalidOperationException">Throws if certificate is missing `subnet/{subnet_id}/public_key`</exception>
        </member>
        <member name="M:EdjCase.ICP.Agent.Models.CertificateDelegation.IsValid(System.Byte[]@)">
            <summary>
            Checks if the Certificate signature is valid and
            outputs the public key of the delegation
            </summary>
            <param name="publicKey">The public key of the delegation</param>
            <returns>True if the certificate signature is valid, otherwise false</returns>
        </member>
        <member name="T:EdjCase.ICP.Agent.Models.Delegation">
            <summary>
            A model that contains data on delegating authority from an identity
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Agent.Models.Delegation.PublicKey">
            <summary>
            The public key from the authorizing identity
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Agent.Models.Delegation.Expiration">
            <summary>
            The expiration when the delegation will no longer be valid
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Agent.Models.Delegation.Targets">
            <summary>
            Optional. A list of canister ids where the delegation can be sent to and be authorized
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Agent.Models.Delegation.Senders">
            <summary>
            Optional. A list of sender ids that can send this delegation and be authorized
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Agent.Models.Delegation.#ctor(System.Byte[],EdjCase.ICP.Candid.Models.ICTimestamp,System.Collections.Generic.List{EdjCase.ICP.Candid.Models.Principal},System.Collections.Generic.List{EdjCase.ICP.Candid.Models.Principal})">
            <param name="publicKey">The public key from the authorizing identity</param>
            <param name="expiration">The expiration when the delegation will no longer be valid</param>
            <param name="targets">Optional. A list of canister ids where the delegation can be sent to and be authorized</param>
            <param name="senders">Optional. A list of sender ids that can send this delegation and be authorized</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:EdjCase.ICP.Agent.Models.Delegation.BuildHashableItem">
            <inheritdoc/>
        </member>
        <member name="M:EdjCase.ICP.Agent.Models.Delegation.ComputeHash(EdjCase.ICP.Candid.Crypto.IHashFunction)">
            <inheritdoc/>
        </member>
        <member name="M:EdjCase.ICP.Agent.Models.Delegation.BuildSigningChallenge">
            <summary>
            Creates a byte array of the data that can be signed by an algorithm for authorization/signature purposes
            </summary>
            <returns>Byte array representation of the data</returns>
        </member>
        <member name="T:EdjCase.ICP.Agent.Models.DelegationChain">
            <summary>
            A model containing a list of signed delegations to authorize an identity 
            to act on behalf of the chain's public key
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Agent.Models.DelegationChain.PublicKey">
            <summary>
            The public key of the identity that has delegated authority
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Agent.Models.DelegationChain.Delegations">
            <summary>
            <para>The chain of delegations to authorize a key<br/>
            Each delegation is signed by its parent key<br/>
            The first delegation's parent is the root key (`PublicKey` in `DelegationChain`)<br/>
            The last delegation is for the key to be authorized</para>
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Agent.Models.DelegationChain.#ctor(EdjCase.ICP.Agent.DerEncodedPublicKey,System.Collections.Generic.List{EdjCase.ICP.Agent.Models.SignedDelegation})">
            <param name="publicKey">The public key of the identity that has delegated authority</param>
            <param name="delegations">The chain of delegations to authorize a key</param>
        </member>
        <member name="M:EdjCase.ICP.Agent.Models.DelegationChain.CreateAsync(EdjCase.ICP.Agent.DerEncodedPublicKey,EdjCase.ICP.Agent.Identities.IIdentity,EdjCase.ICP.Candid.Models.ICTimestamp,System.Collections.Generic.List{EdjCase.ICP.Candid.Models.Principal},System.Collections.Generic.List{EdjCase.ICP.Candid.Models.Principal})">
            <summary>
            Creates a delegation chain from the specified keys
            </summary>
            <param name="keyToDelegateTo">The key to delegate authority to</param>
            <param name="delegatingIdentity">The identity that is signing the delegation</param>
            <param name="expiration">How long to delegate for</param>
            <param name="targets">Optional. List of canister ids to limit delegation to</param>
            <param name="senders">Optional. List of pricipals where requests can originate from</param>
            <returns>A delegation chain signed by the delegating identity</returns>
        </member>
        <member name="T:EdjCase.ICP.Agent.Models.SignedContent">
            <summary>
            A model containing content and the signature information of it
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Agent.Models.SignedContent.Content">
            <summary>
            The content that is signed in the form of key value pairs
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Agent.Models.SignedContent.SenderPublicKey">
            <summary>
            Public key used to authenticate this request, unless anonymous, then null
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Agent.Models.SignedContent.SenderDelegations">
            <summary>
            Optional. A chain of delegations, starting with the one signed by sender_pubkey
            and ending with the one delegating to the key relating to sender_sig.
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Agent.Models.SignedContent.SenderSignature">
            <summary>
            Signature to authenticate this request, unless anonymous, then null
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Agent.Models.SignedContent.#ctor(System.Collections.Generic.Dictionary{System.String,EdjCase.ICP.Candid.Models.IHashable},System.Byte[],System.Collections.Generic.List{EdjCase.ICP.Agent.Models.SignedDelegation},System.Byte[])">
            <param name="content">The content that is signed in the form of key value pairs</param>
            <param name="senderPublicKey">Public key used to authenticate this request, unless anonymous, then null</param>
            <param name="delegations">Optional. A chain of delegations, starting with the one signed by sender_pubkey 
            and ending with the one delegating to the key relating to sender_sig.</param>
            <param name="senderSignature">Signature to authenticate this request, unless anonymous, then null</param>
        </member>
        <member name="M:EdjCase.ICP.Agent.Models.SignedContent.BuildHashableItem">
            <inheritdoc />
        </member>
        <member name="T:EdjCase.ICP.Agent.Models.SignedDelegation">
            <summary>
            A delegation that has been signed by an identity
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Agent.Models.SignedDelegation.Delegation">
            <summary>
            The delegation that is signed
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Agent.Models.SignedDelegation.Signature">
            <summary>
            The signature for the delegation
            </summary>
        </member>
        <member name="M:EdjCase.ICP.Agent.Models.SignedDelegation.#ctor(EdjCase.ICP.Agent.Models.Delegation,System.Byte[])">
            <param name="delegation">The delegation that is signed</param>
            <param name="signature">The signature for the delegation</param>
        </member>
        <member name="M:EdjCase.ICP.Agent.Models.SignedDelegation.CreateAsync(EdjCase.ICP.Agent.DerEncodedPublicKey,EdjCase.ICP.Agent.Identities.IIdentity,EdjCase.ICP.Candid.Models.ICTimestamp,System.Collections.Generic.List{EdjCase.ICP.Candid.Models.Principal},System.Collections.Generic.List{EdjCase.ICP.Candid.Models.Principal})">
            <summary>
            Creates a delegation signed by the delegating identity, authorizing the public key
            </summary>
            <param name="keyToDelegateTo">The key to delegate authority to</param>
            <param name="delegatingIdentity">The identity that is signing the delegation</param>
            <param name="expiration">How long to delegate for</param>
            <param name="targets">Optional. List of canister ids to limit delegation to</param>
            <param name="senders">Optional. List of pricipals where requests can originate from</param>
            <returns>A delegation signed by the delegating identity</returns>
        </member>
        <member name="M:EdjCase.ICP.Agent.Models.SignedDelegation.CreateAsync(EdjCase.ICP.Agent.DerEncodedPublicKey,System.Func{System.Byte[],System.Threading.Tasks.Task{System.Byte[]}},EdjCase.ICP.Candid.Models.ICTimestamp,System.Collections.Generic.List{EdjCase.ICP.Candid.Models.Principal},System.Collections.Generic.List{EdjCase.ICP.Candid.Models.Principal})">
            <summary>
            Creates a delegation signed by the delegating identity, authorizing the public key
            </summary>
            <param name="keyToDelegateTo">The key to delegate authority to</param>
            <param name="signingFunc">Function to sign the delegation bytes</param>
            <param name="expiration">How long to delegate for</param>
            <param name="targets">Optional. List of canister ids to limit delegation to</param>
            <param name="senders">Optional. List of pricipals where requests can originate from</param>
            <returns>A delegation signed by the delegating identity</returns>
        </member>
        <member name="M:EdjCase.ICP.Agent.Models.SignedDelegation.ComputeHash(EdjCase.ICP.Candid.Crypto.IHashFunction)">
            <inheritdoc />
        </member>
        <member name="P:EdjCase.ICP.Agent.Requests.CallRequest.CanisterId">
            <summary>
            The principal of the canister to call
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Agent.Requests.CallRequest.Method">
            <summary>
            Name of the canister method to call
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Agent.Requests.CallRequest.Arg">
            <summary>
            Argument to pass to the canister method
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Agent.Requests.CallRequest.Sender">
            <summary>
            The user who issued the request
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Agent.Requests.CallRequest.IngressExpiry">
            <summary>
            An upper limit on the validity of the request, expressed in nanoseconds since 1970-01-01
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Agent.Requests.CallRequest.Nonce">
            <summary>
            Optional. Arbitrary user-provided data, typically randomly generated. This can be used to create distinct requests with otherwise identical fields.
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Agent.Requests.QueryRequest.CanisterId">
            <summary>
            The principal of the canister to call.
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Agent.Requests.QueryRequest.Method">
            <summary>
            Name of the canister method to call
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Agent.Requests.QueryRequest.Arg">
            <summary>
            Argument to pass to the canister method
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Agent.Requests.QueryRequest.Sender">
            <summary>
            Required. The user who issued the request.
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Agent.Requests.QueryRequest.IngressExpiry">
            <summary>
            Required.  An upper limit on the validity of the request, expressed in nanoseconds since 
            1970-01-01 (like ic0.time()). This avoids replay attacks: The IC will not accept requests, 
            or transition requests from status received to status processing, if their expiry date is in 
            the past. The IC may refuse to accept requests with an ingress expiry date too far in the future. 
            This applies to synchronous and asynchronous requests alike (and could have been called request_expiry).
            </summary>
        </member>
        <member name="P:EdjCase.ICP.Agent.Requests.QueryRequest.Nonce">
            <summary>
            Optional. Arbitrary user-provided data, typically randomly generated. 
            This can be used to create distinct requests with otherwise identical fields.
            </summary>
        </member>
    </members>
</doc>
